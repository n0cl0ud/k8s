<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kubernetes & Terraform Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@cdktf/hcl2json@0.19.0/lib/index.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: fadeIn 1s ease-out;
        }
        
        .subtitle {
            text-align: center;
            opacity: 0.9;
            margin-bottom: 30px;
            font-size: 1.2em;
            animation: fadeIn 1s ease-out 0.3s;
            animation-fill-mode: both;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 30px;
            min-height: 80vh;
        }
        
        .drop-zone {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 3px dashed rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            height: fit-content;
        }
        
        .drop-zone:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: #4CAF50;
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
        }
        
        .drop-zone.drag-over {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
            border-width: 4px;
            transform: scale(1.02);
        }
        
        .drop-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.8;
        }
        
        .drop-text {
            font-size: 1.3em;
            margin-bottom: 15px;
        }
        
        .drop-subtext {
            font-size: 0.9em;
            opacity: 0.7;
        }
        
        .file-input {
            display: none;
        }
        
        .visualization-area {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            min-height: 600px;
            position: relative;
            overflow: auto;
        }
        
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            opacity: 0.5;
        }
        
        .empty-state-icon {
            font-size: 6em;
            margin-bottom: 20px;
        }
        
        .empty-state-text {
            font-size: 1.2em;
        }
        
        .architecture-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 600px;
        }
        
        .resource-node {
            position: absolute;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            min-width: 200px;
            cursor: move;
            transition: all 0.3s ease;
            animation: nodeAppear 0.5s ease-out;
            border: 2px solid transparent;
        }
        
        .resource-node:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }
        
        .resource-node.deployment {
            border-color: #2196F3;
            box-shadow: 0 0 20px rgba(33, 150, 243, 0.3);
        }
        
        .resource-node.service {
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
        }
        
        .resource-node.configmap {
            border-color: #FF9800;
            box-shadow: 0 0 20px rgba(255, 152, 0, 0.3);
        }
        
        .resource-node.secret {
            border-color: #E91E63;
            box-shadow: 0 0 20px rgba(233, 30, 99, 0.3);
        }
        
        .resource-node.ingress {
            border-color: #9C27B0;
            box-shadow: 0 0 20px rgba(156, 39, 176, 0.3);
        }
        
        .resource-node.persistentvolumeclaim {
            border-color: #795548;
            box-shadow: 0 0 20px rgba(121, 85, 72, 0.3);
        }
        
        .resource-node.statefulset {
            border-color: #00BCD4;
            box-shadow: 0 0 20px rgba(0, 188, 212, 0.3);
        }
        
        .resource-node.daemonset {
            border-color: #FFC107;
            box-shadow: 0 0 20px rgba(255, 193, 7, 0.3);
        }
        
        /* Terraform/Cloud resource styles */
        .resource-node.aws_instance,
        .resource-node.aws_eks_cluster,
        .resource-node.aws_rds_instance {
            border-color: #FF9900;
            box-shadow: 0 0 20px rgba(255, 153, 0, 0.3);
            background: linear-gradient(135deg, rgba(255, 153, 0, 0.1), rgba(255, 153, 0, 0.05));
        }
        
        .resource-node.google_compute_instance,
        .resource-node.google_container_cluster,
        .resource-node.google_sql_database_instance {
            border-color: #4285F4;
            box-shadow: 0 0 20px rgba(66, 133, 244, 0.3);
            background: linear-gradient(135deg, rgba(66, 133, 244, 0.1), rgba(66, 133, 244, 0.05));
        }
        
        .resource-node.azurerm_virtual_machine,
        .resource-node.azurerm_kubernetes_cluster,
        .resource-node.azurerm_sql_server {
            border-color: #0078D4;
            box-shadow: 0 0 20px rgba(0, 120, 212, 0.3);
            background: linear-gradient(135deg, rgba(0, 120, 212, 0.1), rgba(0, 120, 212, 0.05));
        }
        
        .resource-node.terraform {
            border-color: #623CE4;
            box-shadow: 0 0 20px rgba(98, 60, 228, 0.3);
            background: linear-gradient(135deg, rgba(98, 60, 228, 0.1), rgba(98, 60, 228, 0.05));
        }
        
        .cloud-provider-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: bold;
        }
        
        .resource-details-extended {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.8em;
        }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .detail-row:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .detail-label {
            opacity: 0.7;
            font-weight: bold;
        }
        
        .detail-value {
            opacity: 0.9;
            text-align: right;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .resource-icon {
            font-size: 2.5em;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .resource-kind {
            font-size: 0.8em;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        
        .resource-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .resource-details {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 10px;
        }
        
        .connection-line {
            position: absolute;
            background: linear-gradient(90deg, rgba(76, 175, 80, 0.8), rgba(76, 175, 80, 0.3));
            height: 2px;
            transform-origin: left center;
            pointer-events: none;
            z-index: 1;
        }
        
        .connection-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid rgba(76, 175, 80, 0.8);
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            right: -8px;
            top: -3px;
        }
        
        .yaml-preview {
            background: #1a1a1a;
            color: #f8f8f2;
            font-family: 'Courier New', monospace;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre;
            font-size: 0.9em;
            border-left: 5px solid #4CAF50;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        .control-button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }
        
        .control-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .control-button.active {
            background: #4CAF50;
        }
        
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.9em;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 5px;
            margin-right: 10px;
            border: 2px solid;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes nodeAppear {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .error-message {
            background: rgba(244, 67, 54, 0.2);
            border: 2px solid #f44336;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            animation: shake 0.5s ease-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        
        .namespace-container {
            background: rgba(255, 255, 255, 0.05);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
        }
        
        .namespace-label {
            position: absolute;
            top: -12px;
            left: 20px;
            background: #2a5298;
            padding: 0 10px;
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        .files-list {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .files-list h3 {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
        }
        
        .file-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .file-name {
            flex: 1;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-resources {
            font-size: 0.8em;
            opacity: 0.7;
            margin-right: 10px;
        }
        
        .remove-file {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.3s ease;
        }
        
        .remove-file:hover {
            background: rgba(244, 67, 54, 0.4);
            transform: scale(1.05);
        }
        
        .project-stats {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Kubernetes & Terraform Visualizer</h1>
        <p class="subtitle">Drag & drop your YAML manifests and Terraform files to visualize the complete infrastructure</p>
        
        <div class="main-layout">
            <div class="left-panel">
                <div class="drop-zone" id="dropZone">
                    <div class="drop-icon">üìÅ</div>
                    <div class="drop-text">Drop your files here</div>
                    <div class="drop-subtext">YAML (.yaml, .yml) and Terraform (.tf) files supported</div>
                    <input type="file" id="fileInput" class="file-input" accept=".yaml,.yml,.tf" multiple>
                </div>
                
                <div id="filesListContainer" class="files-list" style="display: none;">
                    <h3>üìÅ Loaded Files <span id="filesCount" style="opacity: 0.7; font-size: 0.9em;">(0)</span></h3>
                    <div id="filesList"></div>
                </div>
                
                <div id="projectStats" class="project-stats" style="display: none;">
                    <h3>üìä Project Statistics</h3>
                    <div class="stats-grid" id="statsGrid"></div>
                </div>
                
                <div id="errorContainer"></div>
            </div>
            
            <div class="visualization-area">
                <div class="controls">
                    <button class="control-button active" onclick="setLayout('auto')">üîÑ Auto Layout</button>
                    <button class="control-button" onclick="setLayout('hierarchical')">üìä Hierarchical</button>
                    <button class="control-button" onclick="setLayout('circular')">‚≠ï Circular</button>
                    <button class="control-button" onclick="clearVisualization()">üóëÔ∏è Clear</button>
                </div>
                
                <div id="visualizationContainer" class="architecture-container">
                    <div class="empty-state">
                        <div class="empty-state-icon">üéØ</div>
                        <div class="empty-state-text">Drop a YAML manifest to visualize</div>
                    </div>
                </div>
                
                <div class="legend" style="display: none;" id="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="border-color: #2196F3;"></div>
                        <span>Deployment</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="border-color: #4CAF50;"></div>
                        <span>Service</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="border-color: #FF9800;"></div>
                        <span>ConfigMap</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="border-color: #E91E63;"></div>
                        <span>Secret</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="border-color: #9C27B0;"></div>
                        <span>Ingress</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="border-color: #795548;"></div>
                        <span>PVC</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let resources = [];
        let connections = [];
        let currentLayout = 'auto';
        let draggedElement = null;
        let dragOffset = { x: 0, y: 0 };
        let loadedFiles = new Map(); // Store loaded files with their resources

        // Resource icons mapping
        const resourceIcons = {
            // Kubernetes resources
            'Deployment': 'üöÄ',
            'Service': 'üåê',
            'ConfigMap': '‚öôÔ∏è',
            'Secret': 'üîê',
            'Ingress': 'üö™',
            'PersistentVolumeClaim': 'üíæ',
            'StatefulSet': 'üóÇÔ∏è',
            'DaemonSet': 'üòà',
            'Pod': 'üì¶',
            'ReplicaSet': '‚ôªÔ∏è',
            'Job': '‚ö°',
            'CronJob': '‚è∞',
            'NetworkPolicy': 'üõ°Ô∏è',
            'ServiceAccount': 'üë§',
            'Role': 'üé≠',
            'RoleBinding': 'üîó',
            'ClusterRole': 'üëë',
            'ClusterRoleBinding': 'üîó',
            'HorizontalPodAutoscaler': 'üìà',
            'PodDisruptionBudget': 'üõ°Ô∏è',
            
            // AWS resources
            'aws_instance': 'üñ•Ô∏è',
            'aws_eks_cluster': '‚ò∏Ô∏è',
            'aws_rds_instance': 'üóÑÔ∏è',
            'aws_s3_bucket': 'ü™£',
            'aws_vpc': 'üåê',
            'aws_subnet': 'üîó',
            'aws_security_group': 'üõ°Ô∏è',
            'aws_load_balancer': '‚öñÔ∏è',
            'aws_autoscaling_group': 'üìà',
            'aws_iam_role': 'üë§',
            'aws_lambda_function': '‚ö°',
            'aws_cloudwatch_log_group': 'üìä',
            'aws_route53_zone': 'üåç',
            'aws_elasticache_cluster': '‚ö°',
            'aws_ecs_cluster': 'üì¶',
            'aws_ecr_repository': 'üìö',
            
            // GCP resources
            'google_compute_instance': 'üñ•Ô∏è',
            'google_container_cluster': '‚ò∏Ô∏è',
            'google_sql_database_instance': 'üóÑÔ∏è',
            'google_storage_bucket': 'ü™£',
            'google_compute_network': 'üåê',
            'google_compute_subnetwork': 'üîó',
            'google_compute_firewall': 'üõ°Ô∏è',
            'google_compute_target_pool': '‚öñÔ∏è',
            'google_compute_instance_group': 'üìà',
            'google_service_account': 'üë§',
            'google_cloudfunctions_function': '‚ö°',
            'google_logging_project_sink': 'üìä',
            'google_dns_managed_zone': 'üåç',
            'google_redis_instance': '‚ö°',
            'google_cloud_run_service': 'üèÉ',
            'google_artifact_registry_repository': 'üìö',
            
            // Azure resources
            'azurerm_virtual_machine': 'üñ•Ô∏è',
            'azurerm_kubernetes_cluster': '‚ò∏Ô∏è',
            'azurerm_sql_server': 'üóÑÔ∏è',
            'azurerm_storage_account': 'ü™£',
            'azurerm_virtual_network': 'üåê',
            'azurerm_subnet': 'üîó',
            'azurerm_network_security_group': 'üõ°Ô∏è',
            'azurerm_lb': '‚öñÔ∏è',
            'azurerm_virtual_machine_scale_set': 'üìà',
            'azurerm_role_assignment': 'üë§',
            'azurerm_function_app': '‚ö°',
            'azurerm_log_analytics_workspace': 'üìä',
            'azurerm_dns_zone': 'üåç',
            'azurerm_redis_cache': '‚ö°',
            'azurerm_container_group': 'üì¶',
            'azurerm_container_registry': 'üìö',
            
            // Generic Terraform
            'resource': 'üîß',
            'data': 'üìã',
            'variable': 'üî§',
            'output': 'üì§',
            'module': 'üì¶',
            'locals': 'üè†'
        };

        // Setup drag and drop
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const visualizationContainer = document.getElementById('visualizationContainer');

        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFiles(Array.from(files));
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFiles(Array.from(e.target.files));
            }
        });

        // Handle multiple files processing
        function handleFiles(files) {
            const supportedFiles = files.filter(file => 
                file.name.match(/\.(yaml|yml|tf)$/i)
            );
            
            if (supportedFiles.length === 0) {
                showError('Please select YAML (.yaml, .yml) or Terraform (.tf) files');
                return;
            }

            supportedFiles.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        if (file.name.match(/\.tf$/i)) {
                            parseAndAddTerraformFile(file.name, content);
                        } else {
                            parseAndAddFile(file.name, content);
                        }
                    } catch (error) {
                        showError(`Error reading ${file.name}: ${error.message}`);
                    }
                };
                reader.readAsText(file);
            });
        }

        // Parse and add YAML file to the project
        function parseAndAddFile(fileName, content) {
            try {
                const fileResources = [];
                
                // Parse YAML documents
                const documents = jsyaml.loadAll(content);
                
                documents.forEach(doc => {
                    if (doc && doc.kind) {
                        const resource = extractResourceInfo(doc);
                        resource.fileName = fileName;
                        resource.fileType = 'yaml';
                        fileResources.push(resource);
                    }
                });

                if (fileResources.length > 0) {
                    // Store file data
                    loadedFiles.set(fileName, {
                        content: content,
                        resources: fileResources,
                        type: 'yaml'
                    });
                    
                    // Update UI
                    updateFilesList();
                    updateProjectVisualization();
                }
                
            } catch (error) {
                showError(`Error parsing ${fileName}: ${error.message}`);
            }
        }

        // Parse and add Terraform file to the project
        function parseAndAddTerraformFile(fileName, content) {
            try {
                const fileResources = [];
                
                // Simple HCL parser for Terraform
                const terraformResources = parseTerraformContent(content);
                
                terraformResources.forEach(resource => {
                    const resourceInfo = extractTerraformResourceInfo(resource);
                    resourceInfo.fileName = fileName;
                    resourceInfo.fileType = 'terraform';
                    fileResources.push(resourceInfo);
                });

                if (fileResources.length > 0) {
                    // Store file data
                    loadedFiles.set(fileName, {
                        content: content,
                        resources: fileResources,
                        type: 'terraform'
                    });
                    
                    // Update UI
                    updateFilesList();
                    updateProjectVisualization();
                }
                
            } catch (error) {
                showError(`Error parsing Terraform file ${fileName}: ${error.message}`);
            }
        }

        // Simple Terraform HCL parser
        function parseTerraformContent(content) {
            const resources = [];
            
            // Match resource blocks: resource "type" "name" { ... }
            const resourceRegex = /resource\s+"([^"]+)"\s+"([^"]+)"\s*{([^{}]*(?:{[^{}]*}[^{}]*)*)}/g;
            let match;
            
            while ((match = resourceRegex.exec(content)) !== null) {
                const [, type, name, body] = match;
                resources.push({
                    type: 'resource',
                    resourceType: type,
                    name: name,
                    body: body.trim(),
                    fullMatch: match[0]
                });
            }
            
            // Match data blocks: data "type" "name" { ... }
            const dataRegex = /data\s+"([^"]+)"\s+"([^"]+)"\s*{([^{}]*(?:{[^{}]*}[^{}]*)*)}/g;
            while ((match = dataRegex.exec(content)) !== null) {
                const [, type, name, body] = match;
                resources.push({
                    type: 'data',
                    resourceType: type,
                    name: name,
                    body: body.trim(),
                    fullMatch: match[0]
                });
            }
            
            // Match variables: variable "name" { ... }
            const variableRegex = /variable\s+"([^"]+)"\s*{([^{}]*(?:{[^{}]*}[^{}]*)*)}/g;
            while ((match = variableRegex.exec(content)) !== null) {
                const [, name, body] = match;
                resources.push({
                    type: 'variable',
                    name: name,
                    body: body.trim(),
                    fullMatch: match[0]
                });
            }
            
            // Match outputs: output "name" { ... }
            const outputRegex = /output\s+"([^"]+)"\s*{([^{}]*(?:{[^{}]*}[^{}]*)*)}/g;
            while ((match = outputRegex.exec(content)) !== null) {
                const [, name, body] = match;
                resources.push({
                    type: 'output',
                    name: name,
                    body: body.trim(),
                    fullMatch: match[0]
                });
            }
            
            return resources;
        }

        // Extract Terraform resource information
        function extractTerraformResourceInfo(resource) {
            const provider = getProviderFromResourceType(resource.resourceType || resource.type);
            const info = {
                kind: resource.resourceType || resource.type,
                name: resource.name,
                namespace: null, // Terraform resources don't have namespaces
                region: null, // Will be set based on resource attributes
                provider: provider,
                labels: {},
                annotations: {},
                id: `${resource.resourceType || resource.type}-${resource.name}`,
                terraformType: resource.type,
                cloudProvider: provider
            };

            // Parse the body for common attributes
            const attributes = parseHCLAttributes(resource.body);
            
            // Extract common information based on resource type
            switch (resource.resourceType) {
                case 'aws_instance':
                    info.instanceType = attributes.instance_type || 'unknown';
                    info.ami = attributes.ami || 'unknown';
                    info.availabilityZone = attributes.availability_zone || 'unknown';
                    info.region = attributes.availability_zone ? attributes.availability_zone.slice(0, -1) : 'us-west-2';
                    break;
                case 'aws_eks_cluster':
                    info.version = attributes.version || 'unknown';
                    info.roleArn = attributes.role_arn || 'unknown';
                    info.region = 'us-west-2'; // Default, should be extracted from provider config
                    break;
                case 'aws_rds_instance':
                    info.engine = attributes.engine || 'unknown';
                    info.engineVersion = attributes.engine_version || 'unknown';
                    info.instanceClass = attributes.instance_class || 'unknown';
                    info.region = 'us-west-2';
                    break;
                case 'google_compute_instance':
                    info.machineType = attributes.machine_type || 'unknown';
                    info.zone = attributes.zone || 'unknown';
                    info.region = attributes.zone ? attributes.zone.split('-').slice(0, 2).join('-') : 'us-central1';
                    break;
                case 'google_container_cluster':
                    info.location = attributes.location || 'unknown';
                    info.nodeVersion = attributes.node_version || 'unknown';
                    info.region = attributes.location || 'us-central1';
                    break;
                case 'azurerm_virtual_machine':
                    info.vmSize = attributes.vm_size || 'unknown';
                    info.location = attributes.location || 'unknown';
                    info.region = attributes.location || 'East US';
                    break;
                case 'azurerm_kubernetes_cluster':
                    info.location = attributes.location || 'unknown';
                    info.kubernetesVersion = attributes.kubernetes_version || 'unknown';
                    info.region = attributes.location || 'East US';
                    break;
                default:
                    // Try to extract region from common attributes
                    info.region = attributes.region || attributes.location || attributes.zone || 'default';
            }

            // Add common attributes
            info.tags = attributes.tags || {};
            info.count = attributes.count || 1;
            
            return info;
        }

        // Get cloud provider from resource type
        function getProviderFromResourceType(resourceType) {
            if (resourceType.startsWith('aws_')) return 'AWS';
            if (resourceType.startsWith('google_')) return 'GCP';
            if (resourceType.startsWith('azurerm_')) return 'Azure';
            return 'Terraform';
        }

        // Simple HCL attribute parser
        function parseHCLAttributes(body) {
            const attributes = {};
            
            // Match simple key = value pairs
            const simpleAttrRegex = /(\w+)\s*=\s*"([^"]*)"/g;
            let match;
            while ((match = simpleAttrRegex.exec(body)) !== null) {
                attributes[match[1]] = match[2];
            }
            
            // Match numeric values
            const numericAttrRegex = /(\w+)\s*=\s*(\d+(?:\.\d+)?)/g;
            while ((match = numericAttrRegex.exec(body)) !== null) {
                attributes[match[1]] = parseFloat(match[2]);
            }
            
            // Match boolean values
            const boolAttrRegex = /(\w+)\s*=\s*(true|false)/g;
            while ((match = boolAttrRegex.exec(body)) !== null) {
                attributes[match[1]] = match[2] === 'true';
            }
            
            return attributes;
        }

        // Update files list UI
        function updateFilesList() {
            const filesListContainer = document.getElementById('filesListContainer');
            const filesList = document.getElementById('filesList');
            const filesCount = document.getElementById('filesCount');
            
            filesListContainer.style.display = loadedFiles.size > 0 ? 'block' : 'none';
            filesCount.textContent = `(${loadedFiles.size})`;
            
            filesList.innerHTML = '';
            
            loadedFiles.forEach((fileData, fileName) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                
                const resourceCount = fileData.resources.length;
                const resourceTypes = [...new Set(fileData.resources.map(r => r.kind))].join(', ');
                
                fileItem.innerHTML = `
                    <div class="file-name">
                        üìÑ ${fileName}
                    </div>
                    <div class="file-resources">
                        ${resourceCount} resource${resourceCount > 1 ? 's' : ''} (${resourceTypes})
                    </div>
                    <button class="remove-file" onclick="removeFile('${fileName}')">Remove</button>
                `;
                
                filesList.appendChild(fileItem);
            });
        }

        // Update project visualization
        function updateProjectVisualization() {
            // Collect all resources from all files
            resources = [];
            loadedFiles.forEach(fileData => {
                resources.push(...fileData.resources);
            });

            if (resources.length === 0) {
                visualizationContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üéØ</div>
                        <div class="empty-state-text">Drop YAML manifests to visualize</div>
                    </div>
                `;
                document.getElementById('legend').style.display = 'none';
                document.getElementById('projectStats').style.display = 'none';
                return;
            }

            // Find connections between resources
            connections = [];
            findConnections();
            
            // Visualize the architecture
            visualizeArchitecture();
            
            // Update statistics
            updateProjectStats();
            
            // Clear any previous errors
            document.getElementById('errorContainer').innerHTML = '';
        }

        // Remove a file from the project
        function removeFile(fileName) {
            loadedFiles.delete(fileName);
            updateFilesList();
            updateProjectVisualization();
        }

        // Update project statistics
        function updateProjectStats() {
            const projectStats = document.getElementById('projectStats');
            const statsGrid = document.getElementById('statsGrid');
            
            projectStats.style.display = resources.length > 0 ? 'block' : 'none';
            
            // Count resources by type
            const resourceCounts = {};
            resources.forEach(resource => {
                resourceCounts[resource.kind] = (resourceCounts[resource.kind] || 0) + 1;
            });
            
            // Count Kubernetes namespaces and Cloud providers
            const k8sResources = resources.filter(r => r.fileType !== 'terraform');
            const terraformResources = resources.filter(r => r.fileType === 'terraform');
            
            const namespaces = new Set(k8sResources.map(r => r.namespace).filter(ns => ns));
            const providers = new Set(terraformResources.map(r => r.cloudProvider).filter(p => p));
            
            statsGrid.innerHTML = `
                <div class="stat-item">
                    <div class="stat-value">${resources.length}</div>
                    <div class="stat-label">Total Resources</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${loadedFiles.size}</div>
                    <div class="stat-label">Files</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${k8sResources.length}</div>
                    <div class="stat-label">K8s Resources</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${terraformResources.length}</div>
                    <div class="stat-label">Cloud Resources</div>
                </div>
            `;
            
            // Add more specific stats
            if (namespaces.size > 0) {
                const nsStatItem = document.createElement('div');
                nsStatItem.className = 'stat-item';
                nsStatItem.innerHTML = `
                    <div class="stat-value">${namespaces.size}</div>
                    <div class="stat-label">K8s Namespaces</div>
                `;
                statsGrid.appendChild(nsStatItem);
            }
            
            if (providers.size > 0) {
                const providerStatItem = document.createElement('div');
                providerStatItem.className = 'stat-item';
                providerStatItem.innerHTML = `
                    <div class="stat-value">${providers.size}</div>
                    <div class="stat-label">Cloud Providers</div>
                `;
                statsGrid.appendChild(providerStatItem);
            }
            
            // Add resource type counts
            Object.entries(resourceCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 4)
                .forEach(([kind, count]) => {
                    const statItem = document.createElement('div');
                    statItem.className = 'stat-item';
                    statItem.innerHTML = `
                        <div class="stat-value">${count}</div>
                        <div class="stat-label">${kind}s</div>
                    `;
                    statsGrid.appendChild(statItem);
                });
        }

        // Extract resource information
        function extractResourceInfo(resource) {
            const info = {
                kind: resource.kind,
                apiVersion: resource.apiVersion,
                name: resource.metadata?.name || 'unnamed',
                namespace: resource.metadata?.namespace || 'default',
                labels: resource.metadata?.labels || {},
                annotations: resource.metadata?.annotations || {},
                spec: resource.spec || {},
                data: resource.data || {},
                id: `${resource.kind}-${resource.metadata?.name || Math.random()}`
            };

            // Extract additional relevant information based on resource type
            switch (resource.kind) {
                case 'Deployment':
                case 'StatefulSet':
                case 'DaemonSet':
                    info.replicas = resource.spec?.replicas || 1;
                    info.selector = resource.spec?.selector?.matchLabels || {};
                    info.containers = resource.spec?.template?.spec?.containers || [];
                    info.volumes = resource.spec?.template?.spec?.volumes || [];
                    break;
                case 'Service':
                    info.selector = resource.spec?.selector || {};
                    info.ports = resource.spec?.ports || [];
                    info.type = resource.spec?.type || 'ClusterIP';
                    break;
                case 'Ingress':
                    info.rules = resource.spec?.rules || [];
                    info.tls = resource.spec?.tls || [];
                    break;
                case 'ConfigMap':
                case 'Secret':
                    info.dataKeys = Object.keys(resource.data || {});
                    break;
                case 'PersistentVolumeClaim':
                    info.storageClass = resource.spec?.storageClassName || 'default';
                    info.accessModes = resource.spec?.accessModes || [];
                    info.storage = resource.spec?.resources?.requests?.storage || 'unknown';
                    break;
            }

            return info;
        }

        // Find connections between resources
        function findConnections() {
            resources.forEach(resource => {
                // Find Service -> Deployment/StatefulSet connections
                if (resource.kind === 'Service' && resource.selector) {
                    resources.forEach(target => {
                        if (['Deployment', 'StatefulSet', 'DaemonSet', 'Pod'].includes(target.kind)) {
                            if (matchLabels(resource.selector, target.labels) || 
                                matchLabels(resource.selector, target.selector)) {
                                connections.push({
                                    from: resource.id,
                                    to: target.id,
                                    type: 'selector'
                                });
                            }
                        }
                    });
                }

                // Find Ingress -> Service connections
                if (resource.kind === 'Ingress') {
                    resource.rules.forEach(rule => {
                        if (rule.http?.paths) {
                            rule.http.paths.forEach(path => {
                                const serviceName = path.backend?.service?.name;
                                if (serviceName) {
                                    const service = resources.find(r => 
                                        r.kind === 'Service' && r.name === serviceName
                                    );
                                    if (service) {
                                        connections.push({
                                            from: resource.id,
                                            to: service.id,
                                            type: 'backend'
                                        });
                                    }
                                }
                            });
                        }
                    });
                }

                // Find Volume mount connections
                if (['Deployment', 'StatefulSet', 'DaemonSet'].includes(resource.kind)) {
                    resource.volumes?.forEach(volume => {
                        // ConfigMap volumes
                        if (volume.configMap?.name) {
                            const configMap = resources.find(r => 
                                r.kind === 'ConfigMap' && r.name === volume.configMap.name
                            );
                            if (configMap) {
                                connections.push({
                                    from: resource.id,
                                    to: configMap.id,
                                    type: 'volume'
                                });
                            }
                        }
                        // Secret volumes
                        if (volume.secret?.secretName) {
                            const secret = resources.find(r => 
                                r.kind === 'Secret' && r.name === volume.secret.secretName
                            );
                            if (secret) {
                                connections.push({
                                    from: resource.id,
                                    to: secret.id,
                                    type: 'volume'
                                });
                            }
                        }
                        // PVC volumes
                        if (volume.persistentVolumeClaim?.claimName) {
                            const pvc = resources.find(r => 
                                r.kind === 'PersistentVolumeClaim' && 
                                r.name === volume.persistentVolumeClaim.claimName
                            );
                            if (pvc) {
                                connections.push({
                                    from: resource.id,
                                    to: pvc.id,
                                    type: 'volume'
                                });
                            }
                        }
                    });

                    // Environment variable connections
                    resource.containers?.forEach(container => {
                        container.env?.forEach(env => {
                            if (env.valueFrom?.configMapKeyRef?.name) {
                                const configMap = resources.find(r => 
                                    r.kind === 'ConfigMap' && 
                                    r.name === env.valueFrom.configMapKeyRef.name
                                );
                                if (configMap) {
                                    connections.push({
                                        from: resource.id,
                                        to: configMap.id,
                                        type: 'env'
                                    });
                                }
                            }
                            if (env.valueFrom?.secretKeyRef?.name) {
                                const secret = resources.find(r => 
                                    r.kind === 'Secret' && 
                                    r.name === env.valueFrom.secretKeyRef.name
                                );
                                if (secret) {
                                    connections.push({
                                        from: resource.id,
                                        to: secret.id,
                                        type: 'env'
                                    });
                                }
                            }
                        });
                    });
                }
            });
        }

        // Check if labels match
        function matchLabels(selector, labels) {
            if (!selector || !labels) return false;
            return Object.entries(selector).every(([key, value]) => labels[key] === value);
        }

        // Visualize the architecture
        function visualizeArchitecture() {
            visualizationContainer.innerHTML = '';
            document.getElementById('legend').style.display = 'block';

            // Separate Kubernetes and Terraform resources
            const k8sResources = resources.filter(r => r.fileType !== 'terraform');
            const terraformResources = resources.filter(r => r.fileType === 'terraform');

            let containerIndex = 0;

            // Group Kubernetes resources by namespace
            if (k8sResources.length > 0) {
                const namespaces = {};
                k8sResources.forEach(resource => {
                    const ns = resource.namespace || 'default';
                    if (!namespaces[ns]) {
                        namespaces[ns] = [];
                    }
                    namespaces[ns].push(resource);
                });

                // Create namespace containers for Kubernetes
                Object.entries(namespaces).forEach(([namespace, nsResources]) => {
                    if (Object.keys(namespaces).length > 1 || terraformResources.length > 0) {
                        const nsContainer = createNamespaceContainer(`k8s-${namespace}`, containerIndex, 'Kubernetes');
                        nsContainer.id = `ns-k8s-${namespace}`;
                        visualizationContainer.appendChild(nsContainer);
                    }

                    // Position resources based on current layout
                    positionResources(nsResources, `k8s-${namespace}`, containerIndex);
                    
                    // Create resource nodes
                    nsResources.forEach(resource => {
                        const node = createResourceNode(resource);
                        if (Object.keys(namespaces).length > 1 || terraformResources.length > 0) {
                            document.getElementById(`ns-k8s-${namespace}`).appendChild(node);
                        } else {
                            visualizationContainer.appendChild(node);
                        }
                    });

                    containerIndex++;
                });
            }

            // Group Terraform resources by provider
            if (terraformResources.length > 0) {
                const providers = {};
                terraformResources.forEach(resource => {
                    const provider = resource.cloudProvider || 'terraform';
                    if (!providers[provider]) {
                        providers[provider] = [];
                    }
                    providers[provider].push(resource);
                });

                // Create provider containers for Terraform
                Object.entries(providers).forEach(([provider, providerResources]) => {
                    const providerContainer = createProviderContainer(provider, containerIndex);
                    visualizationContainer.appendChild(providerContainer);

                    // Position resources based on current layout
                    positionResources(providerResources, provider, containerIndex);
                    
                    // Create resource nodes
                    providerResources.forEach(resource => {
                        const node = createResourceNode(resource);
                        document.getElementById(`provider-${provider}`).appendChild(node);
                    });

                    containerIndex++;
                });
            }

            // Draw connections after a short delay to ensure nodes are rendered
            setTimeout(() => {
                drawConnections();
            }, 100);
        }

        // Create namespace container
        function createNamespaceContainer(namespace, index, type = 'Kubernetes') {
            const container = document.createElement('div');
            container.className = 'namespace-container';
            container.style.position = 'relative';
            container.style.minHeight = '400px';
            container.style.marginTop = index > 0 ? '20px' : '0';
            
            const label = document.createElement('div');
            label.className = 'namespace-label';
            if (type === 'Kubernetes') {
                const cleanNamespace = namespace.replace('k8s-', '');
                label.textContent = `K8s Namespace: ${cleanNamespace}`;
                label.style.background = '#2196F3';
            }
            container.appendChild(label);
            
            return container;
        }

        // Create provider container for Terraform resources
        function createProviderContainer(provider, index) {
            const container = document.createElement('div');
            container.className = 'namespace-container';
            container.id = `provider-${provider}`;
            container.style.position = 'relative';
            container.style.minHeight = '400px';
            container.style.marginTop = index > 0 ? '20px' : '0';
            
            // Provider-specific styling
            switch (provider) {
                case 'AWS':
                    container.style.borderColor = 'rgba(255, 153, 0, 0.5)';
                    break;
                case 'GCP':
                    container.style.borderColor = 'rgba(66, 133, 244, 0.5)';
                    break;
                case 'Azure':
                    container.style.borderColor = 'rgba(0, 120, 212, 0.5)';
                    break;
                default:
                    container.style.borderColor = 'rgba(98, 60, 228, 0.5)';
            }
            
            const label = document.createElement('div');
            label.className = 'namespace-label';
            label.textContent = `${provider} Infrastructure`;
            
            // Provider-specific label colors
            switch (provider) {
                case 'AWS':
                    label.style.background = '#FF9900';
                    break;
                case 'GCP':
                    label.style.background = '#4285F4';
                    break;
                case 'Azure':
                    label.style.background = '#0078D4';
                    break;
                default:
                    label.style.background = '#623CE4';
            }
            
            container.appendChild(label);
            
            return container;
        }

        // Position resources based on layout
        function positionResources(resources, containerName, containerIndex) {
            const baseY = containerIndex * 450;
            
            switch (currentLayout) {
                case 'hierarchical':
                    positionHierarchical(resources, baseY);
                    break;
                case 'circular':
                    positionCircular(resources, baseY);
                    break;
                default:
                    // Use different positioning for Terraform vs K8s
                    if (containerName.startsWith('k8s-')) {
                        positionAuto(resources, baseY);
                    } else {
                        positionCloudResources(resources, baseY);
                    }
            }
        }

        // Auto layout positioning
        function positionAuto(resources, baseY) {
            // Group resources by type
            const groups = {
                ingress: [],
                service: [],
                workload: [],
                config: [],
                storage: []
            };

            resources.forEach(resource => {
                if (resource.kind === 'Ingress') {
                    groups.ingress.push(resource);
                } else if (resource.kind === 'Service') {
                    groups.service.push(resource);
                } else if (['Deployment', 'StatefulSet', 'DaemonSet', 'Pod'].includes(resource.kind)) {
                    groups.workload.push(resource);
                } else if (['ConfigMap', 'Secret'].includes(resource.kind)) {
                    groups.config.push(resource);
                } else if (resource.kind === 'PersistentVolumeClaim') {
                    groups.storage.push(resource);
                }
            });

            // Position each group
            let x = 50;
            const layers = ['ingress', 'service', 'workload', 'config', 'storage'];
            
            layers.forEach((layer, layerIndex) => {
                const layerResources = groups[layer];
                const spacing = 250;
                let y = baseY + 50;
                
                layerResources.forEach((resource, index) => {
                    resource.x = x;
                    resource.y = y + (index * 150);
                });
                
                if (layerResources.length > 0) {
                    x += spacing;
                }
            });
        }

        // Cloud resources positioning (by service type)
        function positionCloudResources(resources, baseY) {
            // Group cloud resources by service type
            const serviceGroups = {
                compute: [],
                kubernetes: [],
                database: [],
                storage: [],
                network: [],
                other: []
            };

            resources.forEach(resource => {
                const kind = resource.kind.toLowerCase();
                if (kind.includes('instance') || kind.includes('vm')) {
                    serviceGroups.compute.push(resource);
                } else if (kind.includes('cluster') || kind.includes('eks') || kind.includes('gke') || kind.includes('aks')) {
                    serviceGroups.kubernetes.push(resource);
                } else if (kind.includes('rds') || kind.includes('sql') || kind.includes('database')) {
                    serviceGroups.database.push(resource);
                } else if (kind.includes('bucket') || kind.includes('storage')) {
                    serviceGroups.storage.push(resource);
                } else if (kind.includes('vpc') || kind.includes('network') || kind.includes('subnet')) {
                    serviceGroups.network.push(resource);
                } else {
                    serviceGroups.other.push(resource);
                }
            });

            // Position each service group
            let x = 50;
            const spacing = 280;
            const services = ['network', 'compute', 'kubernetes', 'database', 'storage', 'other'];
            
            services.forEach(service => {
                const serviceResources = serviceGroups[service];
                if (serviceResources.length > 0) {
                    let y = baseY + 50;
                    
                    serviceResources.forEach((resource, index) => {
                        resource.x = x;
                        resource.y = y + (index * 120);
                    });
                    
                    x += spacing;
                }
            });
        }

        // Hierarchical layout positioning
        function positionHierarchical(resources, baseY) {
            const levels = assignLevels(resources);
            const levelGroups = {};
            
            resources.forEach(resource => {
                const level = levels[resource.id] || 0;
                if (!levelGroups[level]) {
                    levelGroups[level] = [];
                }
                levelGroups[level].push(resource);
            });

            Object.entries(levelGroups).forEach(([level, levelResources]) => {
                const x = 100 + (parseInt(level) * 300);
                const totalHeight = levelResources.length * 150;
                const startY = baseY + (400 - totalHeight) / 2;
                
                levelResources.forEach((resource, index) => {
                    resource.x = x;
                    resource.y = startY + (index * 150);
                });
            });
        }

        // Assign levels for hierarchical layout
        function assignLevels(resources) {
            const levels = {};
            const visited = new Set();
            
            // Start with resources that have no incoming connections
            resources.forEach(resource => {
                const hasIncoming = connections.some(conn => conn.to === resource.id);
                if (!hasIncoming) {
                    assignLevel(resource.id, 0, levels, visited);
                }
            });

            // Assign levels to remaining resources
            resources.forEach(resource => {
                if (!visited.has(resource.id)) {
                    assignLevel(resource.id, 0, levels, visited);
                }
            });

            return levels;
        }

        function assignLevel(resourceId, level, levels, visited) {
            if (visited.has(resourceId)) return;
            
            visited.add(resourceId);
            levels[resourceId] = level;
            
            // Find connected resources
            connections.forEach(conn => {
                if (conn.from === resourceId) {
                    const targetLevel = Math.max(levels[conn.to] || 0, level + 1);
                    levels[conn.to] = targetLevel;
                }
            });
        }

        // Circular layout positioning
        function positionCircular(resources, baseY) {
            const centerX = 400;
            const centerY = baseY + 200;
            const radius = 200;
            const angleStep = (2 * Math.PI) / resources.length;
            
            resources.forEach((resource, index) => {
                const angle = index * angleStep;
                resource.x = centerX + radius * Math.cos(angle);
                resource.y = centerY + radius * Math.sin(angle);
            });
        }

        // Create resource node element
        function createResourceNode(resource) {
            const node = document.createElement('div');
            node.className = `resource-node ${resource.kind.toLowerCase()}`;
            node.id = resource.id;
            node.style.left = `${resource.x}px`;
            node.style.top = `${resource.y}px`;
            
            const icon = document.createElement('div');
            icon.className = 'resource-icon';
            icon.textContent = resourceIcons[resource.kind] || 'üìÑ';
            
            const kind = document.createElement('div');
            kind.className = 'resource-kind';
            kind.textContent = resource.kind;
            
            const name = document.createElement('div');
            name.className = 'resource-name';
            name.textContent = resource.name;
            
            const details = document.createElement('div');
            details.className = 'resource-details';
            details.innerHTML = getResourceDetails(resource);
            
            node.appendChild(icon);
            node.appendChild(kind);
            node.appendChild(name);
            node.appendChild(details);
            
            // Add cloud provider badge for Terraform resources
            if (resource.fileType === 'terraform' && resource.provider && resource.provider !== 'Terraform') {
                const badge = document.createElement('div');
                badge.className = 'cloud-provider-badge';
                badge.textContent = resource.provider;
                node.appendChild(badge);
            }
            
            // Make node draggable
            node.addEventListener('mousedown', startDrag);
            
            return node;
        }

        // Get resource details HTML
        function getResourceDetails(resource) {
            if (resource.fileType === 'terraform') {
                return getTerraformResourceDetails(resource);
            }
            
            let basicDetails = [];
            let extendedDetails = [];
            
            switch (resource.kind) {
                case 'Deployment':
                case 'StatefulSet':
                    basicDetails.push(`Replicas: ${resource.replicas}`);
                    if (resource.containers && resource.containers.length > 0) {
                        basicDetails.push(`Containers: ${resource.containers.length}`);
                        
                        // Extended details
                        resource.containers.forEach((container, index) => {
                            extendedDetails.push(`Container ${index + 1}: ${container.name}`);
                            if (container.image) extendedDetails.push(`Image: ${container.image}`);
                            if (container.ports) {
                                extendedDetails.push(`Ports: ${container.ports.map(p => p.containerPort).join(', ')}`);
                            }
                        });
                    }
                    if (resource.volumes && resource.volumes.length > 0) {
                        extendedDetails.push(`Volumes: ${resource.volumes.length}`);
                    }
                    break;
                    
                case 'Service':
                    basicDetails.push(`Type: ${resource.type}`);
                    if (resource.ports && resource.ports.length > 0) {
                        basicDetails.push(`Ports: ${resource.ports.map(p => p.port).join(', ')}`);
                        
                        // Extended details
                        resource.ports.forEach(port => {
                            extendedDetails.push(`${port.name || 'Port'}: ${port.port}‚Üí${port.targetPort || port.port}/${port.protocol || 'TCP'}`);
                        });
                    }
                    if (resource.selector && Object.keys(resource.selector).length > 0) {
                        extendedDetails.push(`Selector: ${Object.entries(resource.selector).map(([k, v]) => `${k}=${v}`).join(', ')}`);
                    }
                    break;
                    
                case 'ConfigMap':
                    basicDetails.push(`Keys: ${resource.dataKeys.length}`);
                    if (resource.dataKeys.length > 0) {
                        extendedDetails.push(`Keys: ${resource.dataKeys.slice(0, 5).join(', ')}${resource.dataKeys.length > 5 ? '...' : ''}`);
                    }
                    break;
                    
                case 'Secret':
                    basicDetails.push(`Keys: ${resource.dataKeys.length}`);
                    extendedDetails.push(`Type: ${resource.type || 'Opaque'}`);
                    if (resource.dataKeys.length > 0) {
                        extendedDetails.push(`Keys: ${resource.dataKeys.slice(0, 3).join(', ')}${resource.dataKeys.length > 3 ? '...' : ''}`);
                    }
                    break;
                    
                case 'PersistentVolumeClaim':
                    basicDetails.push(`Storage: ${resource.storage}`);
                    basicDetails.push(`Class: ${resource.storageClass}`);
                    if (resource.accessModes && resource.accessModes.length > 0) {
                        extendedDetails.push(`Access: ${resource.accessModes.join(', ')}`);
                    }
                    break;
                    
                case 'Ingress':
                    if (resource.rules && resource.rules.length > 0) {
                        const hosts = resource.rules.map(r => r.host).filter(h => h);
                        if (hosts.length > 0) {
                            basicDetails.push(`Hosts: ${hosts.slice(0, 2).join(', ')}${hosts.length > 2 ? '...' : ''}`);
                        }
                        
                        // Extended details
                        resource.rules.forEach(rule => {
                            if (rule.host) {
                                extendedDetails.push(`Host: ${rule.host}`);
                            }
                            if (rule.http && rule.http.paths) {
                                rule.http.paths.forEach(path => {
                                    extendedDetails.push(`Path: ${path.path} ‚Üí ${path.backend?.service?.name}:${path.backend?.service?.port?.number}`);
                                });
                            }
                        });
                    }
                    if (resource.tls && resource.tls.length > 0) {
                        extendedDetails.push(`TLS: ${resource.tls.length} certificate(s)`);
                    }
                    break;
                    
                case 'Pod':
                    if (resource.containers && resource.containers.length > 0) {
                        basicDetails.push(`Containers: ${resource.containers.length}`);
                    }
                    if (resource.nodeName) {
                        extendedDetails.push(`Node: ${resource.nodeName}`);
                    }
                    if (resource.phase) {
                        extendedDetails.push(`Phase: ${resource.phase}`);
                    }
                    break;
                    
                default:
                    // Generic details for other resource types
                    if (resource.spec) {
                        const specKeys = Object.keys(resource.spec);
                        if (specKeys.length > 0) {
                            basicDetails.push(`Spec keys: ${specKeys.length}`);
                        }
                    }
            }
            
            // Add namespace if not default
            if (resource.namespace && resource.namespace !== 'default') {
                extendedDetails.unshift(`Namespace: ${resource.namespace}`);
            }
            
            // Add labels info
            if (resource.labels && Object.keys(resource.labels).length > 0) {
                extendedDetails.push(`Labels: ${Object.keys(resource.labels).length}`);
            }
            
            let html = basicDetails.join('<br>');
            
            // Add extended details if available
            if (extendedDetails.length > 0) {
                html += '<div class="resource-details-extended">';
                extendedDetails.forEach(detail => {
                    const [label, value] = detail.split(': ');
                    html += `<div class="detail-row">
                        <span class="detail-label">${label}:</span>
                        <span class="detail-value">${value || ''}</span>
                    </div>`;
                });
                html += '</div>';
            }
            
            return html;
        }

        // Get Terraform resource details HTML
        function getTerraformResourceDetails(resource) {
            let basicDetails = [];
            let extendedDetails = [];
            
            // Add Terraform-specific type
            if (resource.terraformType !== 'resource') {
                basicDetails.push(`Type: ${resource.terraformType}`);
            }
            
            switch (resource.kind) {
                case 'aws_instance':
                    if (resource.instanceType) basicDetails.push(`Type: ${resource.instanceType}`);
                    if (resource.ami) extendedDetails.push(`AMI: ${resource.ami}`);
                    if (resource.availabilityZone) extendedDetails.push(`AZ: ${resource.availabilityZone}`);
                    break;
                    
                case 'aws_eks_cluster':
                    if (resource.version) basicDetails.push(`Version: ${resource.version}`);
                    if (resource.roleArn) extendedDetails.push(`Role: ${resource.roleArn.split('/').pop()}`);
                    break;
                    
                case 'aws_rds_instance':
                    if (resource.engine) basicDetails.push(`Engine: ${resource.engine}`);
                    if (resource.engineVersion) extendedDetails.push(`Version: ${resource.engineVersion}`);
                    if (resource.instanceClass) extendedDetails.push(`Class: ${resource.instanceClass}`);
                    break;
                    
                case 'google_compute_instance':
                    if (resource.machineType) basicDetails.push(`Type: ${resource.machineType.split('/').pop()}`);
                    if (resource.zone) extendedDetails.push(`Zone: ${resource.zone}`);
                    break;
                    
                case 'google_container_cluster':
                    if (resource.location) basicDetails.push(`Location: ${resource.location}`);
                    if (resource.nodeVersion) extendedDetails.push(`Version: ${resource.nodeVersion}`);
                    break;
                    
                case 'azurerm_virtual_machine':
                    if (resource.vmSize) basicDetails.push(`Size: ${resource.vmSize}`);
                    if (resource.location) extendedDetails.push(`Region: ${resource.location}`);
                    break;
                    
                case 'azurerm_kubernetes_cluster':
                    if (resource.location) basicDetails.push(`Region: ${resource.location}`);
                    if (resource.kubernetesVersion) extendedDetails.push(`K8s: ${resource.kubernetesVersion}`);
                    break;
            }
            
            // Add count if > 1
            if (resource.count && resource.count > 1) {
                basicDetails.push(`Count: ${resource.count}`);
            }
            
            // Add tags if available
            if (resource.tags && Object.keys(resource.tags).length > 0) {
                extendedDetails.push(`Tags: ${Object.keys(resource.tags).length}`);
            }
            
            let html = basicDetails.join('<br>');
            
            // Add extended details
            if (extendedDetails.length > 0) {
                html += '<div class="resource-details-extended">';
                extendedDetails.forEach(detail => {
                    const [label, value] = detail.split(': ');
                    html += `<div class="detail-row">
                        <span class="detail-label">${label}:</span>
                        <span class="detail-value">${value || ''}</span>
                    </div>`;
                });
                html += '</div>';
            }
            
            return html;
        }

        // Draw connections between nodes
        function drawConnections() {
            // Remove existing connections
            document.querySelectorAll('.connection-line').forEach(line => line.remove());
            
            connections.forEach(connection => {
                const fromNode = document.getElementById(connection.from);
                const toNode = document.getElementById(connection.to);
                
                if (fromNode && toNode) {
                    drawConnection(fromNode, toNode, connection.type);
                }
            });
        }

        // Draw a single connection
        function drawConnection(fromNode, toNode, type) {
            const line = document.createElement('div');
            line.className = 'connection-line';
            
            const fromRect = fromNode.getBoundingClientRect();
            const toRect = toNode.getBoundingClientRect();
            const containerRect = visualizationContainer.getBoundingClientRect();
            
            const fromX = fromRect.left + fromRect.width / 2 - containerRect.left;
            const fromY = fromRect.top + fromRect.height / 2 - containerRect.top;
            const toX = toRect.left + toRect.width / 2 - containerRect.left;
            const toY = toRect.top + toRect.height / 2 - containerRect.top;
            
            const distance = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            line.style.width = `${distance}px`;
            line.style.left = `${fromX}px`;
            line.style.top = `${fromY}px`;
            line.style.transform = `rotate(${angle}rad)`;
            
            // Add arrow
            const arrow = document.createElement('div');
            arrow.className = 'connection-arrow';
            line.appendChild(arrow);
            
            // Set connection color based on type
            switch (type) {
                case 'selector':
                    line.style.background = 'linear-gradient(90deg, rgba(76, 175, 80, 0.8), rgba(76, 175, 80, 0.3))';
                    arrow.style.borderLeftColor = 'rgba(76, 175, 80, 0.8)';
                    break;
                case 'backend':
                    line.style.background = 'linear-gradient(90deg, rgba(156, 39, 176, 0.8), rgba(156, 39, 176, 0.3))';
                    arrow.style.borderLeftColor = 'rgba(156, 39, 176, 0.8)';
                    break;
                case 'volume':
                    line.style.background = 'linear-gradient(90deg, rgba(255, 152, 0, 0.8), rgba(255, 152, 0, 0.3))';
                    arrow.style.borderLeftColor = 'rgba(255, 152, 0, 0.8)';
                    break;
                case 'env':
                    line.style.background = 'linear-gradient(90deg, rgba(33, 150, 243, 0.8), rgba(33, 150, 243, 0.3))';
                    arrow.style.borderLeftColor = 'rgba(33, 150, 243, 0.8)';
                    break;
            }
            
            visualizationContainer.appendChild(line);
        }

        // Drag functionality
        function startDrag(e) {
            draggedElement = e.currentTarget;
            const rect = draggedElement.getBoundingClientRect();
            const containerRect = visualizationContainer.getBoundingClientRect();
            
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            draggedElement.style.zIndex = 1000;
            draggedElement.style.cursor = 'grabbing';
        }

        function drag(e) {
            if (!draggedElement) return;
            
            const containerRect = visualizationContainer.getBoundingClientRect();
            const x = e.clientX - containerRect.left - dragOffset.x;
            const y = e.clientY - containerRect.top - dragOffset.y;
            
            draggedElement.style.left = `${x}px`;
            draggedElement.style.top = `${y}px`;
            
            // Update resource position
            const resource = resources.find(r => r.id === draggedElement.id);
            if (resource) {
                resource.x = x;
                resource.y = y;
            }
            
            // Redraw connections
            drawConnections();
        }

        function stopDrag() {
            if (draggedElement) {
                draggedElement.style.zIndex = '';
                draggedElement.style.cursor = 'move';
                draggedElement = null;
            }
            
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
        }

        // Layout controls
        function setLayout(layout) {
            currentLayout = layout;
            document.querySelectorAll('.control-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            if (resources.length > 0) {
                visualizeArchitecture();
            }
        }

        function clearVisualization() {
            resources = [];
            connections = [];
            loadedFiles.clear();
            visualizationContainer.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üéØ</div>
                    <div class="empty-state-text">Drop YAML manifests to visualize</div>
                </div>
            `;
            document.getElementById('filesListContainer').style.display = 'none';
            document.getElementById('projectStats').style.display = 'none';
            document.getElementById('legend').style.display = 'none';
            document.getElementById('errorContainer').innerHTML = '';
        }
        
        // Make removeFile function global
        window.removeFile = removeFile;


        // Show error message
        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `
                <div class="error-message">
                    ‚ö†Ô∏è ${message}
                </div>
            `;
        }

        // Example manifests for testing
        function loadExample() {
            // Clear existing data
            loadedFiles.clear();
            
            // Example deployment
            const deploymentYaml = `apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
        env:
        - name: CONFIG_VALUE
          valueFrom:
            configMapKeyRef:
              name: nginx-config
              key: config.value
        volumeMounts:
        - name: config
          mountPath: /etc/nginx/conf.d
      volumes:
      - name: config
        configMap:
          name: nginx-config`;

            // Example service
            const serviceYaml = `apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: LoadBalancer`;

            // Example configmap
            const configmapYaml = `apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  config.value: "production"
  nginx.conf: |
    server {
        listen 80;
        server_name example.com;
        location / {
            root /usr/share/nginx/html;
            index index.html;
        }
    }`;

            // Example ingress
            const ingressYaml = `apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-service
            port:
              number: 80`;

            // StatefulSet example
            const statefulsetYaml = `apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres-db
spec:
  serviceName: postgres-service
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:13
        env:
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: password
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
  - metadata:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi`;

            // Secret example
            const secretYaml = `apiVersion: v1
kind: Secret
metadata:
  name: postgres-secret
type: Opaque
data:
  password: cG9zdGdyZXM=`;
              
            // Terraform examples
            const awsEksYaml = `resource "aws_eks_cluster" "main" {
  name     = "my-eks-cluster"
  role_arn = aws_iam_role.cluster.arn
  version  = "1.27"

  vpc_config {
    subnet_ids = [aws_subnet.private[0].id, aws_subnet.private[1].id]
  }
}

resource "aws_instance" "worker_nodes" {
  count           = 3
  ami             = "ami-0abcdef1234567890"
  instance_type   = "t3.medium"
  availability_zone = "us-west-2a"
  
  tags = {
    Name = "eks-worker-node"
    Environment = "production"
  }
}

resource "aws_rds_instance" "postgres" {
  identifier     = "mydb"
  engine         = "postgres"
  engine_version = "13.7"
  instance_class = "db.t3.micro"
  
  tags = {
    Name = "main-database"
  }
}`;

            const gcpClusterYaml = `resource "google_container_cluster" "primary" {
  name     = "gke-cluster"
  location = "us-central1"
  node_version = "1.27.3-gke.100"
  
  node_config {
    machine_type = "e2-medium"
  }
}

resource "google_compute_instance" "vm" {
  name         = "web-server"
  machine_type = "e2-micro"
  zone         = "us-central1-a"
  
  tags = ["web", "production"]
}`;

            const azureClusterYaml = `resource "azurerm_kubernetes_cluster" "main" {
  name                = "aks-cluster"
  location            = "East US"
  kubernetes_version  = "1.27.1"
  
  default_node_pool {
    name       = "default"
    node_count = 2
    vm_size    = "Standard_D2_v2"
  }
}

resource "azurerm_virtual_machine" "web" {
  name     = "web-vm"
  location = "East US"
  vm_size  = "Standard_B1s"
}`;
              
            // Parse each file separately
            parseAndAddFile('deployment.yaml', deploymentYaml);
            parseAndAddFile('service.yaml', serviceYaml);
            parseAndAddFile('configmap.yaml', configmapYaml);
            parseAndAddFile('ingress.yaml', ingressYaml);
            parseAndAddFile('statefulset.yaml', statefulsetYaml);
            parseAndAddFile('secret.yaml', secretYaml);
            
            // Add Terraform examples
            parseAndAddTerraformFile('aws-infrastructure.tf', awsEksYaml);
            parseAndAddTerraformFile('gcp-resources.tf', gcpClusterYaml);
            parseAndAddTerraformFile('azure-cluster.tf', azureClusterYaml);
        }

        // Add example button to controls
        const controls = document.querySelector('.controls');
        const exampleButton = document.createElement('button');
        exampleButton.className = 'control-button';
        exampleButton.textContent = 'üìù Load Example';
        exampleButton.onclick = loadExample;
        controls.appendChild(exampleButton);
    </script>
</body>
</html>