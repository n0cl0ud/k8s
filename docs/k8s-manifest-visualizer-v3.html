<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K8s Mind Map Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            height: 100vh;
            overflow: hidden;
        }
        
        .main-container {
            display: flex;
            height: 100vh;
        }
        
        /* Sidebar */
        .sidebar {
            width: 500px;
            min-width: 500px;
            background: #161b22;
            border-right: 1px solid #30363d;
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-header {
            padding: 24px;
            background: #21262d;
            border-bottom: 1px solid #30363d;
        }
        
        .sidebar-header h1 {
            font-size: 1.4em;
            color: #58a6ff;
            margin-bottom: 12px;
            font-weight: 700;
        }
        
        .sidebar-header p {
            font-size: 0.85em;
            color: #8b949e;
        }
        
        .drop-zone {
            margin: 20px;
            padding: 40px 24px;
            border: 2px dashed #30363d;
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(88, 166, 255, 0.05);
        }
        
        .drop-zone:hover {
            border-color: #58a6ff;
            background: rgba(88, 166, 255, 0.1);
        }
        
        .drop-zone.drag-over {
            border-color: #39d353;
            background: rgba(57, 211, 83, 0.1);
        }
        
        .file-input {
            display: none;
        }
        
        .resources-panel {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .resource-section {
            margin-bottom: 24px;
            background: rgba(33, 38, 45, 0.6);
            border-radius: 12px;
            border: 1px solid #30363d;
            overflow: hidden;
        }
        
        .section-header {
            padding: 16px 20px;
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border-bottom: 1px solid #30363d;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .section-header:hover {
            background: linear-gradient(135deg, #30363d 0%, #21262d 100%);
        }
        
        .section-icon {
            font-size: 1.8em;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            flex-shrink: 0;
        }
        
        .section-icon.aws {
            background: linear-gradient(135deg, #ff9900 0%, #ff7700 100%);
        }
        
        .section-icon.gcp {
            background: linear-gradient(135deg, #4285f4 0%, #1a73e8 100%);
        }
        
        .section-icon.azure {
            background: linear-gradient(135deg, #0078d4 0%, #005a9e 100%);
        }
        
        .section-icon.kubernetes {
            background: linear-gradient(135deg, #326ce5 0%, #1a45a1 100%);
        }
        
        .section-icon.database {
            background: linear-gradient(135deg, #2ea043 0%, #1f7a2e 100%);
        }
        
        .section-icon.storage {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
        }
        
        .section-title {
            flex: 1;
        }
        
        .section-name {
            font-size: 1.1em;
            font-weight: 600;
            color: #c9d1d9;
            margin-bottom: 2px;
        }
        
        .section-description {
            font-size: 0.8em;
            color: #8b949e;
        }
        
        .section-stats {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.85em;
        }
        
        .stat-badge {
            background: rgba(88, 166, 255, 0.2);
            color: #58a6ff;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 500;
        }
        
        .expand-icon {
            font-size: 1.2em;
            color: #8b949e;
            transition: transform 0.2s;
        }
        
        .section-header.expanded .expand-icon {
            transform: rotate(90deg);
        }
        
        .section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .section-header.expanded + .section-content {
            max-height: 800px;
        }
        
        .resource-group {
            padding: 16px 20px;
            border-bottom: 1px solid rgba(48, 54, 61, 0.3);
        }
        
        .resource-group:last-child {
            border-bottom: none;
        }
        
        .group-title {
            font-size: 0.9em;
            font-weight: 600;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .group-icon {
            font-size: 1.1em;
        }
        
        .resource-item {
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 14px 16px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }
        
        .resource-item:hover {
            background: #30363d;
            border-color: #58a6ff;
            transform: translateX(4px);
        }
        
        .resource-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }
        
        .resource-icon {
            font-size: 1.4em;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(88, 166, 255, 0.1);
            border-radius: 6px;
            flex-shrink: 0;
        }
        
        .resource-details {
            flex: 1;
            min-width: 0;
        }
        
        .resource-name {
            font-size: 0.9em;
            font-weight: 600;
            color: #c9d1d9;
            margin-bottom: 2px;
            word-break: break-word;
        }
        
        .resource-type {
            font-size: 0.75em;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .resource-namespace {
            font-size: 0.7em;
            color: #58a6ff;
            background: rgba(88, 166, 255, 0.1);
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
        }
        
        .resource-actions {
            display: flex;
            gap: 6px;
        }
        
        .action-btn {
            background: rgba(139, 148, 158, 0.1);
            border: 1px solid #30363d;
            color: #8b949e;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7em;
            transition: all 0.2s;
        }
        
        .action-btn:hover {
            background: rgba(88, 166, 255, 0.2);
            border-color: #58a6ff;
            color: #58a6ff;
        }
        
        .action-btn.remove {
            color: #f85149;
        }
        
        .action-btn.remove:hover {
            background: rgba(248, 81, 73, 0.2);
            border-color: #f85149;
        }
        
        .files-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #30363d;
        }
        
        .files-title {
            font-size: 0.9em;
            font-weight: 600;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-item {
            background: rgba(33, 38, 45, 0.4);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px 14px;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }
        
        .file-item:hover {
            background: rgba(48, 54, 61, 0.6);
        }
        
        .file-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .file-name {
            font-size: 0.85em;
            color: #c9d1d9;
        }
        
        .file-count {
            font-size: 0.75em;
            color: #8b949e;
            background: rgba(139, 148, 158, 0.1);
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        .remove-file-btn {
            background: transparent;
            border: none;
            color: #8b949e;
            padding: 4px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
        }
        
        .remove-file-btn:hover {
            background: rgba(248, 81, 73, 0.2);
            color: #f85149;
        }
        
        /* Canvas */
        .canvas-area {
            flex: 1;
            position: relative;
            background: #0d1117;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(88, 166, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(57, 211, 83, 0.1) 0%, transparent 50%);
        }
        
        .toolbar {
            position: absolute;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }
        
        .toolbar-btn {
            background: rgba(22, 27, 34, 0.8);
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }
        
        .toolbar-btn:hover {
            background: rgba(88, 166, 255, 0.2);
            border-color: #58a6ff;
        }
        
        .toolbar-btn.active {
            background: rgba(88, 166, 255, 0.3);
            border-color: #58a6ff;
            color: #58a6ff;
        }
        
        /* Canvas viewport */
        #canvas {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: auto;
            cursor: grab;
        }
        
        /* Provider zones on canvas */
        .provider-zone {
            position: absolute;
            border: 2px solid;
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }
        
        .provider-zone.aws {
            background: rgba(255, 153, 0, 0.08);
            border-color: rgba(255, 153, 0, 0.3);
        }
        
        .provider-zone.gcp {
            background: rgba(66, 133, 244, 0.08);
            border-color: rgba(66, 133, 244, 0.3);
        }
        
        .provider-zone.azure {
            background: rgba(0, 120, 212, 0.08);
            border-color: rgba(0, 120, 212, 0.3);
        }
        
        .provider-zone.kubernetes {
            background: rgba(50, 108, 229, 0.08);
            border-color: rgba(50, 108, 229, 0.3);
        }
        
        .zone-header {
            position: absolute;
            top: -15px;
            left: 20px;
            background: #0d1117;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid;
        }
        
        .zone-header.aws {
            color: #ff9900;
            border-color: rgba(255, 153, 0, 0.5);
            background: linear-gradient(135deg, #0d1117 0%, rgba(255, 153, 0, 0.1) 100%);
        }
        
        .zone-header.gcp {
            color: #4285f4;
            border-color: rgba(66, 133, 244, 0.5);
            background: linear-gradient(135deg, #0d1117 0%, rgba(66, 133, 244, 0.1) 100%);
        }
        
        .zone-header.azure {
            color: #0078d4;
            border-color: rgba(0, 120, 212, 0.5);
            background: linear-gradient(135deg, #0d1117 0%, rgba(0, 120, 212, 0.1) 100%);
        }
        
        .zone-header.kubernetes {
            color: #326ce5;
            border-color: rgba(50, 108, 229, 0.5);
            background: linear-gradient(135deg, #0d1117 0%, rgba(50, 108, 229, 0.1) 100%);
        }
        
        .zone-stats {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            margin-left: 8px;
        }
        
        #canvas.dragging {
            cursor: grabbing;
        }
        
        .viewport {
            position: relative;
            width: 3000px;
            height: 3000px;
            transform-origin: 0 0;
        }
        
        /* Mind Map Nodes */
        .mind-node {
            position: absolute;
            background: linear-gradient(135deg, #21262d 0%, #161b22 100%);
            border: 2px solid #30363d;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            user-select: none;
        }
        
        .mind-node:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            border-color: #58a6ff;
            z-index: 50;
        }
        
        .mind-node.expanded {
            border-color: #39d353;
            box-shadow: 0 0 0 2px rgba(57, 211, 83, 0.3);
        }
        
        .mind-node.dragging {
            z-index: 100;
            transform: scale(1.05);
            cursor: grabbing;
        }
        
        .mind-node.highlighted {
            border-color: #39d353 !important;
            box-shadow: 0 0 0 3px rgba(57, 211, 83, 0.5), 0 8px 24px rgba(0, 0, 0, 0.6) !important;
            transform: translateY(-2px) scale(1.05) !important;
            z-index: 200 !important;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 0 3px rgba(57, 211, 83, 0.5), 0 8px 24px rgba(0, 0, 0, 0.6);
            }
            50% {
                box-shadow: 0 0 0 6px rgba(57, 211, 83, 0.3), 0 12px 32px rgba(0, 0, 0, 0.8);
            }
        }
        
        /* Node types */
        .mind-node.deployment { border-left: 4px solid #1f6feb; }
        .mind-node.service { border-left: 4px solid #238636; }
        .mind-node.ingress { border-left: 4px solid #8957e5; }
        .mind-node.configmap { border-left: 4px solid #fb8500; }
        .mind-node.secret { border-left: 4px solid #da3633; }
        .mind-node.statefulset { border-left: 4px solid #0969da; }
        .mind-node.persistentvolumeclaim { border-left: 4px solid #2da44e; }
        
        /* Node sizes */
        .mind-node.size-compact {
            padding: 12px 16px;
            width: 200px;
        }
        
        .mind-node.size-normal {
            padding: 16px 20px;
            width: 260px;
        }
        
        .mind-node.size-expanded {
            padding: 20px 24px;
            width: 320px;
            min-height: 200px;
        }
        
        .node-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .node-icon {
            font-size: 1.8em;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(88, 166, 255, 0.1);
            border-radius: 8px;
            flex-shrink: 0;
        }
        
        .node-content {
            flex: 1;
            min-width: 0;
        }
        
        .node-type {
            font-size: 0.7em;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 2px;
        }
        
        .node-name {
            font-size: 1em;
            font-weight: 600;
            color: #c9d1d9;
            line-height: 1.2;
            word-break: break-word;
        }
        
        .expand-indicator {
            width: 20px;
            height: 20px;
            background: #30363d;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            color: #8b949e;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        
        .expand-indicator:hover {
            background: #58a6ff;
            color: white;
        }
        
        .expand-indicator.expanded {
            background: #39d353;
            color: white;
            transform: rotate(90deg);
        }
        
        .node-details {
            margin-top: 12px;
            font-size: 0.85em;
            color: #8b949e;
            line-height: 1.4;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .mind-node.expanded .node-details {
            opacity: 1;
            max-height: 300px;
        }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
        }
        
        .detail-row:last-child {
            border-bottom: none;
        }
        
        .detail-label {
            color: #8b949e;
            font-size: 0.8em;
        }
        
        .detail-value {
            color: #58a6ff;
            font-weight: 500;
            font-size: 0.8em;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .child-nodes {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        .mind-node.expanded .child-nodes {
            opacity: 1;
            pointer-events: all;
        }
        
        /* Connection lines */
        .connection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .connection-line {
            stroke: #30363d;
            stroke-width: 2;
            fill: none;
            opacity: 0.6;
            transition: all 0.3s ease;
        }
        
        .connection-line.active {
            stroke: #58a6ff;
            stroke-width: 3;
            opacity: 1;
            stroke-dasharray: 5, 5;
            animation: dash 20s linear infinite;
        }
        
        @keyframes dash {
            to {
                stroke-dashoffset: -100;
            }
        }
        
        .connection-line.service { stroke: #238636; }
        .connection-line.config { stroke: #fb8500; }
        .connection-line.volume { stroke: #8957e5; }
        
        /* Minimap */
        .minimap {
            position: absolute;
            bottom: 16px;
            right: 16px;
            width: 200px;
            height: 150px;
            background: rgba(22, 27, 34, 0.9);
            border: 1px solid #30363d;
            border-radius: 6px;
            backdrop-filter: blur(10px);
            overflow: hidden;
        }
        
        .minimap-viewport {
            position: absolute;
            border: 2px solid #58a6ff;
            background: rgba(88, 166, 255, 0.1);
            cursor: move;
        }
        
        /* Stats panel */
        .stats-panel {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(22, 27, 34, 0.9);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 16px;
            backdrop-filter: blur(10px);
            min-width: 180px;
        }
        
        .stats-title {
            font-size: 0.9em;
            font-weight: 600;
            color: #58a6ff;
            margin-bottom: 12px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            font-size: 0.8em;
        }
        
        .stat-label {
            color: #8b949e;
        }
        
        .stat-value {
            color: #c9d1d9;
            font-weight: 500;
        }
        
        /* Empty state */
        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0.6;
        }
        
        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 16px;
        }
        
        .empty-state-text {
            font-size: 1.1em;
            color: #8b949e;
        }
        
        /* Animations */
        @keyframes nodeAppear {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .mind-node {
            animation: nodeAppear 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Zoom indicator */
        .zoom-indicator {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: rgba(22, 27, 34, 0.9);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.8em;
            color: #8b949e;
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h1>🧠 K8s Mind Map</h1>
                <p>Interactive resource visualization</p>
            </div>
            
            <div class="drop-zone" id="dropZone">
                <div style="font-size: 2em; margin-bottom: 8px;">📁</div>
                <div>Drop files or click to browse</div>
                <div style="font-size: 0.75em; margin-top: 4px; color: #8b949e;">
                    YAML, YML, TF files
                </div>
                <input type="file" id="fileInput" class="file-input" accept=".yaml,.yml,.tf" multiple>
            </div>
            
            <div class="resources-panel">
                <div id="resourcesSections"></div>
                
                <div class="files-section">
                    <div class="files-title">
                        <span>📄</span>
                        <span>Loaded Files</span>
                    </div>
                    <div id="filesList"></div>
                </div>
            </div>
        </div>
        
        <!-- Canvas -->
        <div class="canvas-area">
            <div class="toolbar">
                <button class="toolbar-btn active" onclick="setMode('mind')">🧠 Mind Map</button>
                <button class="toolbar-btn" onclick="setMode('flow')">🌊 Flow</button>
                <button class="toolbar-btn" onclick="setMode('tree')">🌳 Tree</button>
                <button class="toolbar-btn" onclick="expandAll()">📂 Expand All</button>
                <button class="toolbar-btn" onclick="collapseAll()">📁 Collapse All</button>
                <button class="toolbar-btn" onclick="centerView()">🎯 Center</button>
                <button class="toolbar-btn" onclick="clearAll()">🗑️ Clear</button>
                <button class="toolbar-btn" onclick="loadExample()">📝 Example</button>
            </div>
            
            <div id="canvas">
                <div class="viewport" id="viewport">
                    <svg class="connection-svg" id="connectionSvg"></svg>
                    <div class="empty-state" id="emptyState">
                        <div class="empty-state-icon">🎯</div>
                        <div class="empty-state-text">Drop files to start mapping</div>
                    </div>
                </div>
            </div>
            
            <div class="stats-panel" id="statsPanel" style="display: none;">
                <div class="stats-title">📊 Statistics</div>
                <div id="statsContent"></div>
            </div>
            
            <div class="zoom-indicator" id="zoomIndicator">100%</div>
        </div>
    </div>

    <script>
        // Global state
        let resources = [];
        let connections = [];
        let loadedFiles = new Map();
        let currentMode = 'mind';
        let selectedNode = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let zoomLevel = 1;
        let panOffset = { x: 0, y: 0 };
        let expandedNodes = new Set();
        
        // Resource icons
        const icons = {
            'Deployment': '🚀', 'Service': '🌐', 'ConfigMap': '⚙️', 'Secret': '🔐',
            'Ingress': '🚪', 'PersistentVolumeClaim': '💾', 'StatefulSet': '🗂️',
            'DaemonSet': '😈', 'Pod': '📦', 'Job': '⚡', 'CronJob': '⏰',
            'aws_instance': '🖥️', 'aws_eks_cluster': '☸️', 'aws_rds_instance': '🗄️',
            'google_compute_instance': '🖥️', 'google_container_cluster': '☸️',
            'azurerm_virtual_machine': '🖥️', 'azurerm_kubernetes_cluster': '☸️',
            'default': '📄'
        };
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupDragDrop();
            setupCanvas();
            setupKeyboardShortcuts();
        });
        
        function setupDragDrop() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            
            dropZone.addEventListener('click', () => fileInput.click());
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                handleFiles(e.dataTransfer.files);
            });
            
            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });
        }
        
        function setupCanvas() {
            const canvas = document.getElementById('canvas');
            const viewport = document.getElementById('viewport');
            
            // Node interaction
            viewport.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            // Zoom
            canvas.addEventListener('wheel', handleWheel);
            
            // Pan
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            
            canvas.addEventListener('mousedown', (e) => {
                if (e.target === canvas || e.target === viewport) {
                    isPanning = true;
                    panStart = { x: e.clientX - panOffset.x, y: e.clientY - panOffset.y };
                    canvas.style.cursor = 'grabbing';
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    panOffset.x = e.clientX - panStart.x;
                    panOffset.y = e.clientY - panStart.y;
                    updateViewport();
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isPanning) {
                    isPanning = false;
                    canvas.style.cursor = 'grab';
                }
            });
        }
        
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case '0':
                            e.preventDefault();
                            resetZoom();
                            break;
                        case '=':
                        case '+':
                            e.preventDefault();
                            zoomIn();
                            break;
                        case '-':
                            e.preventDefault();
                            zoomOut();
                            break;
                    }
                }
                
                switch (e.key) {
                    case 'Escape':
                        deselectAll();
                        break;
                    case ' ':
                        e.preventDefault();
                        centerView();
                        break;
                }
            });
        }
        
        function handleFiles(files) {
            Array.from(files).forEach(file => {
                if (file.name.match(/\.(yaml|yml|tf)$/i)) {
                    const reader = new FileReader();
                    reader.onload = (e) => processFile(file.name, e.target.result);
                    reader.readAsText(file);
                }
            });
        }
        
        function processFile(fileName, content) {
            try {
                const fileResources = [];
                
                if (fileName.endsWith('.tf')) {
                    fileResources.push(...parseTerraform(content));
                } else {
                    const docs = jsyaml.loadAll(content);
                    docs.forEach(doc => {
                        if (doc && doc.kind) {
                            fileResources.push(parseKubernetes(doc));
                        }
                    });
                }
                
                if (fileResources.length > 0) {
                    loadedFiles.set(fileName, { content, resources: fileResources });
                    updateFilesList();
                    updateVisualization();
                    updateResourcesSections();
                }
            } catch (error) {
                console.error('Error processing file:', error);
            }
        }
        
        function parseKubernetes(doc) {
            const resource = {
                id: `${doc.kind}-${doc.metadata?.name || Math.random()}`,
                kind: doc.kind,
                name: doc.metadata?.name || 'unnamed',
                namespace: doc.metadata?.namespace || 'default',
                labels: doc.metadata?.labels || {},
                spec: doc.spec || {},
                type: 'kubernetes',
                children: [],
                parent: null,
                expanded: false,
                x: 0,
                y: 0
            };
            
            // Extract relationships and children
            switch (doc.kind) {
                case 'Deployment':
                case 'StatefulSet':
                    resource.replicas = doc.spec?.replicas || 1;
                    resource.containers = doc.spec?.template?.spec?.containers?.map(c => ({
                        id: `container-${c.name}`,
                        name: c.name,
                        image: c.image,
                        ports: c.ports || [],
                        type: 'container',
                        parent: resource.id
                    })) || [];
                    resource.children = resource.containers;
                    break;
                    
                case 'Service':
                    resource.selector = doc.spec?.selector || {};
                    resource.ports = doc.spec?.ports || [];
                    resource.serviceType = doc.spec?.type || 'ClusterIP';
                    break;
                    
                case 'ConfigMap':
                case 'Secret':
                    resource.dataKeys = Object.keys(doc.data || {});
                    resource.children = resource.dataKeys.map(key => ({
                        id: `${resource.id}-${key}`,
                        name: key,
                        type: 'data-key',
                        parent: resource.id
                    }));
                    break;
                    
                case 'Ingress':
                    resource.rules = doc.spec?.rules || [];
                    resource.children = resource.rules.map((rule, i) => ({
                        id: `${resource.id}-rule-${i}`,
                        name: rule.host || `Rule ${i + 1}`,
                        paths: rule.http?.paths || [],
                        type: 'ingress-rule',
                        parent: resource.id
                    }));
                    break;
            }
            
            return resource;
        }
        
        function parseTerraform(content) {
            const resources = [];
            const resourceRegex = /resource\s+"([^"]+)"\s+"([^"]+)"\s*{/g;
            let match;
            
            while ((match = resourceRegex.exec(content)) !== null) {
                resources.push({
                    id: `${match[1]}-${match[2]}`,
                    kind: match[1],
                    name: match[2],
                    type: 'terraform',
                    provider: match[1].split('_')[0],
                    children: [],
                    parent: null,
                    expanded: false,
                    x: 0,
                    y: 0
                });
            }
            
            return resources;
        }
        
        function updateFilesList() {
            const filesList = document.getElementById('filesList');
            filesList.innerHTML = '';
            
            loadedFiles.forEach((fileData, fileName) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div class="file-info">
                        <span>📄</span>
                        <span class="file-name">${fileName}</span>
                        <span class="file-count">${fileData.resources.length}</span>
                    </div>
                    <button class="remove-file-btn" onclick="removeFile('${fileName}')" title="Remove file">×</button>
                `;
                filesList.appendChild(fileItem);
            });
        }
        
        function updateResourcesSections() {
            const sectionsContainer = document.getElementById('resourcesSections');
            sectionsContainer.innerHTML = '';
            
            // Group resources by provider/category
            const sections = {
                aws: {
                    name: 'Amazon Web Services',
                    description: 'AWS cloud resources and services',
                    icon: '☁️',
                    className: 'aws',
                    resources: resources.filter(r => r.kind && r.kind.startsWith('aws_')),
                    groups: {
                        compute: { name: 'Compute', icon: '🖥️', resources: [] },
                        database: { name: 'Database', icon: '🗄️', resources: [] },
                        storage: { name: 'Storage', icon: '💾', resources: [] },
                        network: { name: 'Network', icon: '🌐', resources: [] },
                        kubernetes: { name: 'Kubernetes', icon: '☸️', resources: [] },
                        other: { name: 'Other', icon: '📦', resources: [] }
                    }
                },
                gcp: {
                    name: 'Google Cloud Platform',
                    description: 'GCP cloud resources and services',
                    icon: '🔵',
                    className: 'gcp',
                    resources: resources.filter(r => r.kind && r.kind.startsWith('google_')),
                    groups: {
                        compute: { name: 'Compute', icon: '🖥️', resources: [] },
                        database: { name: 'Database', icon: '🗄️', resources: [] },
                        storage: { name: 'Storage', icon: '💾', resources: [] },
                        network: { name: 'Network', icon: '🌐', resources: [] },
                        kubernetes: { name: 'Kubernetes', icon: '☸️', resources: [] },
                        other: { name: 'Other', icon: '📦', resources: [] }
                    }
                },
                azure: {
                    name: 'Microsoft Azure',
                    description: 'Azure cloud resources and services',
                    icon: '🔷',
                    className: 'azure',
                    resources: resources.filter(r => r.kind && r.kind.startsWith('azurerm_')),
                    groups: {
                        compute: { name: 'Compute', icon: '🖥️', resources: [] },
                        database: { name: 'Database', icon: '🗄️', resources: [] },
                        storage: { name: 'Storage', icon: '💾', resources: [] },
                        network: { name: 'Network', icon: '🌐', resources: [] },
                        kubernetes: { name: 'Kubernetes', icon: '☸️', resources: [] },
                        other: { name: 'Other', icon: '📦', resources: [] }
                    }
                },
                kubernetes: {
                    name: 'Kubernetes',
                    description: 'Native Kubernetes resources',
                    icon: '☸️',
                    className: 'kubernetes',
                    resources: resources.filter(r => r.type === 'kubernetes'),
                    groups: {
                        workloads: { name: 'Workloads', icon: '🚀', resources: [] },
                        services: { name: 'Services', icon: '🌐', resources: [] },
                        config: { name: 'Config & Secrets', icon: '⚙️', resources: [] },
                        storage: { name: 'Storage', icon: '💾', resources: [] },
                        networking: { name: 'Networking', icon: '🔗', resources: [] },
                        other: { name: 'Other', icon: '📦', resources: [] }
                    }
                }
            };
            
            // Categorize resources within each section
            Object.values(sections).forEach(section => {
                section.resources.forEach(resource => {
                    if (section.className === 'aws') {
                        if (resource.kind.includes('instance') || resource.kind.includes('autoscaling')) {
                            section.groups.compute.resources.push(resource);
                        } else if (resource.kind.includes('rds') || resource.kind.includes('dynamodb')) {
                            section.groups.database.resources.push(resource);
                        } else if (resource.kind.includes('s3') || resource.kind.includes('ebs')) {
                            section.groups.storage.resources.push(resource);
                        } else if (resource.kind.includes('vpc') || resource.kind.includes('subnet') || resource.kind.includes('lb')) {
                            section.groups.network.resources.push(resource);
                        } else if (resource.kind.includes('eks')) {
                            section.groups.kubernetes.resources.push(resource);
                        } else {
                            section.groups.other.resources.push(resource);
                        }
                    } else if (section.className === 'gcp') {
                        if (resource.kind.includes('instance') || resource.kind.includes('group')) {
                            section.groups.compute.resources.push(resource);
                        } else if (resource.kind.includes('sql') || resource.kind.includes('datastore')) {
                            section.groups.database.resources.push(resource);
                        } else if (resource.kind.includes('storage') || resource.kind.includes('bucket')) {
                            section.groups.storage.resources.push(resource);
                        } else if (resource.kind.includes('network') || resource.kind.includes('firewall')) {
                            section.groups.network.resources.push(resource);
                        } else if (resource.kind.includes('container') || resource.kind.includes('cluster')) {
                            section.groups.kubernetes.resources.push(resource);
                        } else {
                            section.groups.other.resources.push(resource);
                        }
                    } else if (section.className === 'azure') {
                        if (resource.kind.includes('virtual_machine') || resource.kind.includes('scale_set')) {
                            section.groups.compute.resources.push(resource);
                        } else if (resource.kind.includes('sql') || resource.kind.includes('cosmosdb')) {
                            section.groups.database.resources.push(resource);
                        } else if (resource.kind.includes('storage')) {
                            section.groups.storage.resources.push(resource);
                        } else if (resource.kind.includes('network') || resource.kind.includes('lb')) {
                            section.groups.network.resources.push(resource);
                        } else if (resource.kind.includes('kubernetes')) {
                            section.groups.kubernetes.resources.push(resource);
                        } else {
                            section.groups.other.resources.push(resource);
                        }
                    } else if (section.className === 'kubernetes') {
                        if (['Deployment', 'StatefulSet', 'DaemonSet', 'Pod', 'Job', 'CronJob'].includes(resource.kind)) {
                            section.groups.workloads.resources.push(resource);
                        } else if (['Service'].includes(resource.kind)) {
                            section.groups.services.resources.push(resource);
                        } else if (['ConfigMap', 'Secret'].includes(resource.kind)) {
                            section.groups.config.resources.push(resource);
                        } else if (['PersistentVolumeClaim', 'PersistentVolume'].includes(resource.kind)) {
                            section.groups.storage.resources.push(resource);
                        } else if (['Ingress', 'NetworkPolicy'].includes(resource.kind)) {
                            section.groups.networking.resources.push(resource);
                        } else {
                            section.groups.other.resources.push(resource);
                        }
                    }
                });
            });
            
            // Render sections
            Object.entries(sections).forEach(([sectionKey, section]) => {
                if (section.resources.length > 0) {
                    const sectionElement = createResourceSection(sectionKey, section);
                    sectionsContainer.appendChild(sectionElement);
                }
            });
        }
        
        function createResourceSection(sectionKey, section) {
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'resource-section';
            
            const totalResources = section.resources.length;
            const activeGroups = Object.values(section.groups).filter(g => g.resources.length > 0).length;
            
            sectionDiv.innerHTML = `
                <div class="section-header" onclick="toggleSection('${sectionKey}')">
                    <div class="section-icon ${section.className}">
                        ${section.icon}
                    </div>
                    <div class="section-title">
                        <div class="section-name">${section.name}</div>
                        <div class="section-description">${section.description}</div>
                    </div>
                    <div class="section-stats">
                        <span class="stat-badge">${totalResources} resources</span>
                        <span class="stat-badge">${activeGroups} groups</span>
                    </div>
                    <div class="expand-icon">▶</div>
                </div>
                <div class="section-content" id="section-content-${sectionKey}">
                    ${Object.entries(section.groups)
                        .filter(([groupKey, group]) => group.resources.length > 0)
                        .map(([groupKey, group]) => `
                            <div class="resource-group">
                                <div class="group-title">
                                    <span class="group-icon">${group.icon}</span>
                                    <span>${group.name} (${group.resources.length})</span>
                                </div>
                                ${group.resources.map(resource => `
                                    <div class="resource-item" onclick="focusResource('${resource.id}')">
                                        <div class="resource-info">
                                            <div class="resource-icon">
                                                ${icons[resource.kind] || icons.default}
                                            </div>
                                            <div class="resource-details">
                                                <div class="resource-name">
                                                    ${resource.name}
                                                    ${resource.namespace && resource.namespace !== 'default' ? 
                                                        `<span class="resource-namespace">${resource.namespace}</span>` : ''}
                                                </div>
                                                <div class="resource-type">${resource.kind}</div>
                                            </div>
                                        </div>
                                        <div class="resource-actions">
                                            <button class="action-btn" onclick="event.stopPropagation(); expandResource('${resource.id}')" title="Expand details">📋</button>
                                            <button class="action-btn" onclick="event.stopPropagation(); centerOnResource('${resource.id}')" title="Center on canvas">🎯</button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        `).join('')}
                </div>
            `;
            
            return sectionDiv;
        }
        
        function updateVisualization() {
            // Collect all resources
            resources = [];
            loadedFiles.forEach(fileData => {
                resources.push(...fileData.resources);
            });
            
            if (resources.length === 0) {
                document.getElementById('emptyState').style.display = 'block';
                document.getElementById('statsPanel').style.display = 'none';
                return;
            }
            
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('statsPanel').style.display = 'block';
            
            findConnections();
            applyLayout();
            render();
            updateStats();
            updateResourcesSections();
        }
        
        function findConnections() {
            connections = [];
            
            resources.forEach(resource => {
                if (resource.kind === 'Service' && resource.selector) {
                    resources.forEach(target => {
                        if (['Deployment', 'StatefulSet'].includes(target.kind)) {
                            if (matchLabels(resource.selector, target.labels)) {
                                connections.push({
                                    from: resource.id,
                                    to: target.id,
                                    type: 'service'
                                });
                            }
                        }
                    });
                }
                
                if (resource.kind === 'Ingress') {
                    resource.rules?.forEach(rule => {
                        rule.paths?.forEach(path => {
                            const serviceName = path.backend?.service?.name;
                            if (serviceName) {
                                const service = resources.find(r => r.kind === 'Service' && r.name === serviceName);
                                if (service) {
                                    connections.push({
                                        from: resource.id,
                                        to: service.id,
                                        type: 'ingress'
                                    });
                                }
                            }
                        });
                    });
                }
            });
        }
        
        function matchLabels(selector, labels) {
            return Object.entries(selector).every(([key, value]) => labels[key] === value);
        }
        
        function applyLayout() {
            switch (currentMode) {
                case 'mind':
                    applyMindMapLayout();
                    break;
                case 'flow':
                    applyFlowLayout();
                    break;
                case 'tree':
                    applyTreeLayout();
                    break;
            }
        }
        
        function applyMindMapLayout() {
            // Group resources by provider first
            const providerGroups = {
                aws: resources.filter(r => r.kind && r.kind.startsWith('aws_')),
                gcp: resources.filter(r => r.kind && r.kind.startsWith('google_')),
                azure: resources.filter(r => r.kind && r.kind.startsWith('azurerm_')),
                kubernetes: resources.filter(r => r.type === 'kubernetes')
            };
            
            // Define zone positions and sizes
            const zones = {
                aws: { x: 100, y: 100, width: 600, height: 400, color: 'aws' },
                gcp: { x: 800, y: 100, width: 600, height: 400, color: 'gcp' },
                azure: { x: 100, y: 600, width: 600, height: 400, color: 'azure' },
                kubernetes: { x: 800, y: 600, width: 600, height: 400, color: 'kubernetes' }
            };
            
            // Position resources within their zones
            Object.entries(providerGroups).forEach(([provider, providerResources]) => {
                if (providerResources.length > 0) {
                    const zone = zones[provider];
                    const padding = 50;
                    const nodeSpacing = 240;
                    const rowHeight = 200;
                    
                    // Calculate grid layout within zone
                    const nodesPerRow = Math.floor((zone.width - padding * 2) / nodeSpacing);
                    const maxNodesPerRow = Math.max(2, nodesPerRow);
                    
                    providerResources.forEach((resource, index) => {
                        const row = Math.floor(index / maxNodesPerRow);
                        const col = index % maxNodesPerRow;
                        
                        // Center the row if it's not full
                        const nodesInThisRow = Math.min(maxNodesPerRow, providerResources.length - (row * maxNodesPerRow));
                        const rowStartX = zone.x + padding + (zone.width - padding * 2 - (nodesInThisRow * nodeSpacing)) / 2;
                        
                        resource.x = rowStartX + (col * nodeSpacing);
                        resource.y = zone.y + padding + (row * rowHeight);
                        
                        // Store zone info for rendering
                        resource.zone = provider;
                    });
                }
            });
            
            // Store zones for rendering
            window.currentZones = zones;
        }
        
        function applyFlowLayout() {
            // Group by provider first
            const providerGroups = {
                aws: resources.filter(r => r.kind && r.kind.startsWith('aws_')),
                gcp: resources.filter(r => r.kind && r.kind.startsWith('google_')),
                azure: resources.filter(r => r.kind && r.kind.startsWith('azurerm_')),
                kubernetes: resources.filter(r => r.type === 'kubernetes')
            };
            
            const zoneWidth = 400;
            const zoneHeight = 600;
            let currentX = 100;
            const startY = 100;
            
            // Create zones for active providers
            const zones = {};
            Object.entries(providerGroups).forEach(([provider, providerResources]) => {
                if (providerResources.length > 0) {
                    zones[provider] = {
                        x: currentX,
                        y: startY,
                        width: zoneWidth,
                        height: zoneHeight,
                        color: provider
                    };
                    currentX += zoneWidth + 100;
                }
            });
            
            window.currentZones = zones;
            
            // Position resources within zones using flow logic
            Object.entries(providerGroups).forEach(([provider, providerResources]) => {
                if (providerResources.length > 0 && zones[provider]) {
                    const zone = zones[provider];
                    const padding = 50;
                    const columnWidth = 300;
                    const nodeHeight = 180;
                    
                    // Build flow columns for this provider
                    const columns = [];
                    const processed = new Set();
                    const roots = providerResources.filter(r => !connections.some(c => c.to === r.id));
                    
                    let currentColumn = [...roots];
                    while (currentColumn.length > 0) {
                        columns.push(currentColumn);
                        currentColumn.forEach(r => processed.add(r.id));
                        
                        const nextColumn = [];
                        currentColumn.forEach(resource => {
                            connections
                                .filter(c => c.from === resource.id && !processed.has(c.to) && providerResources.includes(resources.find(r => r.id === c.to)))
                                .forEach(c => {
                                    const target = resources.find(r => r.id === c.to);
                                    if (target && !nextColumn.includes(target)) {
                                        nextColumn.push(target);
                                    }
                                });
                        });
                        
                        currentColumn = nextColumn;
                    }
                    
                    // Add unprocessed from this provider
                    const unprocessed = providerResources.filter(r => !processed.has(r.id));
                    if (unprocessed.length > 0) {
                        columns.push(unprocessed);
                    }
                    
                    // Position columns within zone
                    columns.forEach((column, colIndex) => {
                        const x = zone.x + padding + (colIndex * columnWidth);
                        
                        column.forEach((resource, rowIndex) => {
                            resource.x = x;
                            resource.y = zone.y + padding + (rowIndex * nodeHeight);
                            resource.zone = provider;
                        });
                    });
                }
            });
        }
        
        function applyTreeLayout() {
            // Group by provider
            const providerGroups = {
                aws: resources.filter(r => r.kind && r.kind.startsWith('aws_')),
                gcp: resources.filter(r => r.kind && r.kind.startsWith('google_')),
                azure: resources.filter(r => r.kind && r.kind.startsWith('azurerm_')),
                kubernetes: resources.filter(r => r.type === 'kubernetes')
            };
            
            const zoneWidth = 500;
            const zoneHeight = 800;
            let currentX = 100;
            const startY = 100;
            
            // Create zones
            const zones = {};
            Object.entries(providerGroups).forEach(([provider, providerResources]) => {
                if (providerResources.length > 0) {
                    zones[provider] = {
                        x: currentX,
                        y: startY,
                        width: zoneWidth,
                        height: zoneHeight,
                        color: provider
                    };
                    currentX += zoneWidth + 80;
                }
            });
            
            window.currentZones = zones;
            
            // Build tree within each zone
            Object.entries(providerGroups).forEach(([provider, providerResources]) => {
                if (providerResources.length > 0 && zones[provider]) {
                    const zone = zones[provider];
                    const padding = 50;
                    const levelHeight = 200;
                    const nodeSpacing = 220;
                    
                    const levels = [];
                    const processed = new Set();
                    
                    // Build levels for this provider
                    const roots = providerResources.filter(r => !connections.some(c => c.to === r.id));
                    let currentLevel = [...roots];
                    
                    while (currentLevel.length > 0) {
                        levels.push(currentLevel);
                        currentLevel.forEach(r => processed.add(r.id));
                        
                        const nextLevel = [];
                        currentLevel.forEach(resource => {
                            connections
                                .filter(c => c.from === resource.id && !processed.has(c.to) && providerResources.includes(resources.find(r => r.id === c.to)))
                                .forEach(c => {
                                    const target = resources.find(r => r.id === c.to);
                                    if (target && !nextLevel.includes(target)) {
                                        nextLevel.push(target);
                                    }
                                });
                        });
                        
                        currentLevel = nextLevel;
                    }
                    
                    // Add unprocessed
                    const unprocessed = providerResources.filter(r => !processed.has(r.id));
                    if (unprocessed.length > 0) {
                        levels.push(unprocessed);
                    }
                    
                    // Position levels within zone
                    levels.forEach((level, levelIndex) => {
                        const y = zone.y + padding + (levelIndex * levelHeight);
                        const totalWidth = level.length * nodeSpacing;
                        const startX = zone.x + zone.width / 2 - totalWidth / 2;
                        
                        level.forEach((resource, index) => {
                            resource.x = startX + (index * nodeSpacing);
                            resource.y = y;
                            resource.zone = provider;
                        });
                    });
                }
            });
        }
        
        function render() {
            const viewport = document.getElementById('viewport');
            
            // Clear existing nodes and zones
            const existingNodes = viewport.querySelectorAll('.mind-node, .provider-zone');
            existingNodes.forEach(node => node.remove());
            
            // Render provider zones first (for all modes)
            if (window.currentZones) {
                renderProviderZones(viewport);
            }
            
            // Render nodes
            resources.forEach(resource => {
                const node = createMindNode(resource);
                viewport.appendChild(node);
            });
            
            // Render connections
            renderConnections();
        }
        
        function renderProviderZones(viewport) {
            // Group resources by provider to show only active zones
            const activeProviders = {
                aws: resources.filter(r => r.kind && r.kind.startsWith('aws_')),
                gcp: resources.filter(r => r.kind && r.kind.startsWith('google_')),
                azure: resources.filter(r => r.kind && r.kind.startsWith('azurerm_')),
                kubernetes: resources.filter(r => r.type === 'kubernetes')
            };
            
            const providerNames = {
                aws: 'Amazon Web Services',
                gcp: 'Google Cloud Platform', 
                azure: 'Microsoft Azure',
                kubernetes: 'Kubernetes'
            };
            
            const providerIcons = {
                aws: '☁️',
                gcp: '🔵',
                azure: '🔷',
                kubernetes: '☸️'
            };
            
            Object.entries(window.currentZones).forEach(([provider, zone]) => {
                const providerResources = activeProviders[provider];
                if (providerResources && providerResources.length > 0) {
                    const zoneDiv = document.createElement('div');
                    zoneDiv.className = `provider-zone ${zone.color}`;
                    zoneDiv.style.left = `${zone.x}px`;
                    zoneDiv.style.top = `${zone.y}px`;
                    zoneDiv.style.width = `${zone.width}px`;
                    zoneDiv.style.height = `${zone.height}px`;
                    
                    const header = document.createElement('div');
                    header.className = `zone-header ${zone.color}`;
                    header.style.cursor = 'pointer';
                    header.onclick = () => {
                        // Sync with sidebar section
                        const sectionHeader = document.querySelector(`[onclick="toggleSection('${provider}')"]`);
                        if (sectionHeader) {
                            sectionHeader.click();
                        }
                        // Highlight zone temporarily  
                        zoneDiv.style.transform = 'scale(1.02)';
                        setTimeout(() => {
                            zoneDiv.style.transform = 'scale(1)';
                        }, 200);
                    };
                    header.innerHTML = `
                        <span>${providerIcons[provider]}</span>
                        <span>${providerNames[provider]}</span>
                        <span class="zone-stats">${providerResources.length} resources</span>
                    `;
                    
                    zoneDiv.appendChild(header);
                    viewport.appendChild(zoneDiv);
                }
            });
        }
        
        function createMindNode(resource) {
            const node = document.createElement('div');
            node.className = `mind-node size-${resource.expanded ? 'expanded' : 'normal'} ${resource.kind.toLowerCase()}`;
            node.id = resource.id;
            node.style.left = `${resource.x}px`;
            node.style.top = `${resource.y}px`;
            
            if (resource.expanded) {
                node.classList.add('expanded');
            }
            
            const icon = icons[resource.kind] || icons.default;
            const hasChildren = resource.children && resource.children.length > 0;
            
            let details = '';
            if (resource.replicas !== undefined) {
                details += `<div class="detail-row">
                    <span class="detail-label">Replicas</span>
                    <span class="detail-value">${resource.replicas}</span>
                </div>`;
            }
            if (resource.ports && resource.ports.length > 0) {
                details += `<div class="detail-row">
                    <span class="detail-label">Ports</span>
                    <span class="detail-value">${resource.ports.map(p => p.port || p.containerPort).join(', ')}</span>
                </div>`;
            }
            if (resource.serviceType) {
                details += `<div class="detail-row">
                    <span class="detail-label">Type</span>
                    <span class="detail-value">${resource.serviceType}</span>
                </div>`;
            }
            if (resource.dataKeys && resource.dataKeys.length > 0) {
                details += `<div class="detail-row">
                    <span class="detail-label">Keys</span>
                    <span class="detail-value">${resource.dataKeys.length}</span>
                </div>`;
            }
            if (resource.namespace && resource.namespace !== 'default') {
                details += `<div class="detail-row">
                    <span class="detail-label">Namespace</span>
                    <span class="detail-value">${resource.namespace}</span>
                </div>`;
            }
            
            node.innerHTML = `
                <div class="node-header">
                    <div class="node-icon">${icon}</div>
                    <div class="node-content">
                        <div class="node-type">${resource.kind}</div>
                        <div class="node-name">${resource.name}</div>
                    </div>
                    ${hasChildren ? `<div class="expand-indicator ${resource.expanded ? 'expanded' : ''}" onclick="toggleExpand('${resource.id}')">${resource.expanded ? '−' : '+'}</div>` : ''}
                </div>
                ${details ? `<div class="node-details">${details}</div>` : ''}
            `;
            
            // Add click handler for expansion
            if (hasChildren) {
                node.addEventListener('click', (e) => {
                    if (!e.target.closest('.expand-indicator')) {
                        toggleExpand(resource.id);
                    }
                });
            }
            
            return node;
        }
        
        function renderConnections() {
            const svg = document.getElementById('connectionSvg');
            svg.innerHTML = '';
            
            connections.forEach(connection => {
                const fromNode = document.getElementById(connection.from);
                const toNode = document.getElementById(connection.to);
                
                if (fromNode && toNode) {
                    const fromRect = fromNode.getBoundingClientRect();
                    const toRect = toNode.getBoundingClientRect();
                    const canvasRect = svg.getBoundingClientRect();
                    
                    const fromX = fromRect.left + fromRect.width / 2 - canvasRect.left;
                    const fromY = fromRect.top + fromRect.height / 2 - canvasRect.top;
                    const toX = toRect.left + toRect.width / 2 - canvasRect.left;
                    const toY = toRect.top + toRect.height / 2 - canvasRect.top;
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    
                    // Curved connection
                    const midX = (fromX + toX) / 2;
                    const midY = (fromY + toY) / 2;
                    const controlOffset = 50;
                    
                    path.setAttribute('d', `M ${fromX} ${fromY} Q ${midX} ${midY - controlOffset} ${toX} ${toY}`);
                    path.setAttribute('class', `connection-line ${connection.type}`);
                    
                    svg.appendChild(path);
                }
            });
        }
        
        function updateStats() {
            const statsContent = document.getElementById('statsContent');
            
            const stats = {
                'Resources': resources.length,
                'Expanded': expandedNodes.size,
                'Connections': connections.length,
                'Namespaces': [...new Set(resources.filter(r => r.namespace).map(r => r.namespace))].length,
                'Files': loadedFiles.size
            };
            
            statsContent.innerHTML = Object.entries(stats)
                .map(([label, value]) => `
                    <div class="stat-item">
                        <span class="stat-label">${label}</span>
                        <span class="stat-value">${value}</span>
                    </div>
                `).join('');
        }
        
        // Mouse event handlers
        function handleMouseDown(e) {
            const node = e.target.closest('.mind-node');
            if (node && !e.target.closest('.expand-indicator')) {
                selectedNode = node;
                isDragging = true;
                
                const rect = node.getBoundingClientRect();
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                node.classList.add('dragging');
                e.preventDefault();
            }
        }
        
        function handleMouseMove(e) {
            if (isDragging && selectedNode) {
                const canvasRect = document.getElementById('canvas').getBoundingClientRect();
                const viewportRect = document.getElementById('viewport').getBoundingClientRect();
                
                const x = (e.clientX - viewportRect.left - dragOffset.x) / zoomLevel;
                const y = (e.clientY - viewportRect.top - dragOffset.y) / zoomLevel;
                
                selectedNode.style.left = `${x}px`;
                selectedNode.style.top = `${y}px`;
                
                // Update resource position
                const resource = resources.find(r => r.id === selectedNode.id);
                if (resource) {
                    resource.x = x;
                    resource.y = y;
                }
                
                // Update connections in real-time
                renderConnections();
            }
        }
        
        function handleMouseUp(e) {
            if (isDragging && selectedNode) {
                selectedNode.classList.remove('dragging');
                isDragging = false;
                selectedNode = null;
            }
        }
        
        // Zoom and pan
        function handleWheel(e) {
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(3, zoomLevel * delta));
            
            if (newZoom !== zoomLevel) {
                zoomLevel = newZoom;
                updateViewport();
                updateZoomIndicator();
            }
        }
        
        function updateViewport() {
            const viewport = document.getElementById('viewport');
            viewport.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px) scale(${zoomLevel})`;
        }
        
        function updateZoomIndicator() {
            document.getElementById('zoomIndicator').textContent = `${Math.round(zoomLevel * 100)}%`;
        }
        
        // Control functions
        window.setMode = function(mode) {
            currentMode = mode;
            document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            if (resources.length > 0) {
                applyLayout();
                render();
            }
        };
        
        window.toggleExpand = function(resourceId) {
            const resource = resources.find(r => r.id === resourceId);
            const node = document.getElementById(resourceId);
            
            if (resource && node) {
                resource.expanded = !resource.expanded;
                
                if (resource.expanded) {
                    expandedNodes.add(resourceId);
                    node.classList.add('expanded');
                } else {
                    expandedNodes.delete(resourceId);
                    node.classList.remove('expanded');
                }
                
                // Re-render the node
                const newNode = createMindNode(resource);
                node.parentNode.replaceChild(newNode, node);
                
                updateStats();
            }
        };
        
        window.expandAll = function() {
            resources.forEach(resource => {
                if (resource.children && resource.children.length > 0) {
                    resource.expanded = true;
                    expandedNodes.add(resource.id);
                }
            });
            render();
            updateStats();
        };
        
        window.collapseAll = function() {
            resources.forEach(resource => {
                resource.expanded = false;
            });
            expandedNodes.clear();
            render();
            updateStats();
        };
        
        window.centerView = function() {
            if (resources.length > 0) {
                const bounds = resources.reduce((acc, r) => ({
                    minX: Math.min(acc.minX, r.x),
                    maxX: Math.max(acc.maxX, r.x),
                    minY: Math.min(acc.minY, r.y),
                    maxY: Math.max(acc.maxY, r.y)
                }), { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });
                
                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;
                
                const canvas = document.getElementById('canvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                panOffset.x = canvasRect.width / 2 - centerX * zoomLevel;
                panOffset.y = canvasRect.height / 2 - centerY * zoomLevel;
                
                updateViewport();
            }
        };
        
        window.clearAll = function() {
            resources = [];
            connections = [];
            loadedFiles.clear();
            expandedNodes.clear();
            updateFilesList();
            updateVisualization();
        };
        
        window.removeFile = function(fileName) {
            loadedFiles.delete(fileName);
            updateFilesList();
            updateVisualization();
        };
        
        window.toggleSection = function(sectionKey) {
            const header = event.currentTarget;
            const content = document.getElementById(`section-content-${sectionKey}`);
            
            header.classList.toggle('expanded');
            
            if (header.classList.contains('expanded')) {
                content.style.maxHeight = content.scrollHeight + 'px';
            } else {
                content.style.maxHeight = '0';
            }
        };
        
        window.focusResource = function(resourceId) {
            // Highlight resource on canvas
            const node = document.getElementById(resourceId);
            if (node) {
                // Remove previous highlights
                document.querySelectorAll('.mind-node.highlighted').forEach(n => n.classList.remove('highlighted'));
                
                // Add highlight
                node.classList.add('highlighted');
                
                // Center on resource
                centerOnResource(resourceId);
                
                // Remove highlight after 3 seconds
                setTimeout(() => {
                    node.classList.remove('highlighted');
                }, 3000);
            }
        };
        
        window.expandResource = function(resourceId) {
            if (!expandedNodes.has(resourceId)) {
                toggleExpand(resourceId);
            }
        };
        
        window.centerOnResource = function(resourceId) {
            const resource = resources.find(r => r.id === resourceId);
            if (resource) {
                const canvas = document.getElementById('canvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                panOffset.x = canvasRect.width / 2 - resource.x * zoomLevel;
                panOffset.y = canvasRect.height / 2 - resource.y * zoomLevel;
                
                updateViewport();
            }
        };
        
        function deselectAll() {
            if (selectedNode) {
                selectedNode.classList.remove('selected');
                selectedNode = null;
            }
        }
        
        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.2, 3);
            updateViewport();
            updateZoomIndicator();
        }
        
        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.2, 0.1);
            updateViewport();
            updateZoomIndicator();
        }
        
        function resetZoom() {
            zoomLevel = 1;
            panOffset = { x: 0, y: 0 };
            updateViewport();
            updateZoomIndicator();
        }
        
        // Load example
        window.loadExample = function() {
            const exampleYaml = `apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-frontend
  labels:
    app: web
    tier: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
      tier: frontend
  template:
    metadata:
      labels:
        app: web
        tier: frontend
    spec:
      containers:
      - name: nginx
        image: nginx:1.20
        ports:
        - containerPort: 80
        env:
        - name: CONFIG_PATH
          valueFrom:
            configMapKeyRef:
              name: web-config
              key: config.path
        volumeMounts:
        - name: config-volume
          mountPath: /etc/config
      volumes:
      - name: config-volume
        configMap:
          name: web-config
---
apiVersion: v1
kind: Service
metadata:
  name: web-service
spec:
  selector:
    app: web
    tier: frontend
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
  type: LoadBalancer
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
  - host: api.example.com
    http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 8080
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: web-config
data:
  config.path: "/app/config"
  nginx.conf: |
    server {
        listen 80;
        location / {
            root /usr/share/nginx/html;
            index index.html;
        }
    }
  app.properties: |
    debug=false
    environment=production
---
apiVersion: v1
kind: Secret
metadata:
  name: web-secrets
type: Opaque
data:
  database-password: cGFzc3dvcmQ=
  api-key: YWJjZGVmZ2hpams=
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: database
spec:
  serviceName: db-service
  replicas: 1
  selector:
    matchLabels:
      app: database
  template:
    metadata:
      labels:
        app: database
    spec:
      containers:
      - name: postgres
        image: postgres:13
        env:
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: web-secrets
              key: database-password
        volumeMounts:
        - name: db-storage
          mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
  - metadata:
      name: db-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi`;
            
            processFile('example-microservice.yaml', exampleYaml);
        };
    </script>
</body>
</html>